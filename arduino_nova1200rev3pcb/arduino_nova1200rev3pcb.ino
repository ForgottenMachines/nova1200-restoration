// Novarev3PCB frontpanel monitor software
// Marcel van Herk

// 20200705: first version with most functionality
// put keyboard based display on LCD 3 (move to 0?)
// EEPROM address = 50..53
// switch banks not yet implemented
// uses Serial1 to connect to Nova
// Tested: LCDs leds keyboards regs eeprom0
// TODO lights: eepromread eepromwrite memrd memwr serialrd serialwr
// TODO implement Nova switches A--T (T=test)
// TODO possible tests: LCD, keys&switch, lights, leds, novaregs, serial, eeproms, analog, 
// (spi, extlcd, wl433.92, int, lightint), 
// 20200705: adc N, tested dac, lcd writes big, led does color lights and teensy led
//           display 0=keypad monitor, 3=serial out, readk, reads commands
// 20200707: added Nova virtual console K mode to load dgnasm output
//           removed old interactive mode; fix keypad mode display with cursor; allow empty help
// 20200708: modified test 9 6 7: test lights unconnected to Nova (was assemble)
// 20200709: Added SIMULATED, key repeat, buffer lcd help string; implement most switches
// 20200710: Added wireFail flag: detects if no hardware connected and switches of I2C to enable serial control only; blink led on boot
// 20200711: Added basic command (loads basic code program memory); lights for eeprom read and write; start on simulator
// 20200712: Removed basic command now tape .basic; also works without eeprom; cleaned nova.simh; started on TTO/TTI
//           Commands step and run now do something on simulator
// 20200712: First working version
// 20200713: TTO works when calling from nova.simh; lights: C, ION, RUN,FETCH,DEFER=running, EXEC=off
//           Prog load is restore (down) store (up); Todo: step key
//           Accelerated EEPROM read; basic2 tape; fix simulated step;
// 20200714: Allow to work on Teensy3.5 with few lights and switches and single I2C display
// 20200717: Removed c_str casts, few TEENSY35 fixes, I2C delay to 1us (0us works too, but 1 more stable)

#include <U8g2lib.h>
#include <EEPROM.h>
#define TEENSY

#ifdef __MK64FX512__
#define TEENSY35
#endif

// graphics library
U8G2_SSD1306_128X32_UNIVISION_F_SW_I2C u8g2(U8G2_R0, A9, A8); 
U8G2LOG u8g2log;

#define SIMULATED

#ifdef SIMULATED
  unsigned short NovaMem[16384];
  int NovaRegs[4];
  int NovaPC=0;
  int NovaC=0;

void Serialwrite(int a)
{ Serial.write(a);
#ifdef TEENSY35
  selectDisplay(0);
  u8g2log.write(a);
#endif
}

#define MEMSIZE 16384
#define M NovaMem
#define AC NovaRegs
#define PC NovaPC
#define C NovaC
#include "C:/software/nova1200-restoration/arduino_nova1200rev3pcb/nova.simh"

#endif

#include <SoftWire.h>
SoftWire softwarei2c(A8, A9);
#define Wire softwarei2c

// single user basic 1 from about 1969
const unsigned char basictape[]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
248,255,0,0,83,40,2,0,70,1,3,4,29,15,231,64,
218,64,230,64,166,0,240,255,16,0,28,254,0,0,3,0,
4,0,5,0,6,0,7,0,10,0,11,0,15,0,18,0,
20,0,64,0,65,0,81,0,85,0,90,0,240,255,32,0,
248,245,94,0,124,0,127,0,128,0,135,0,138,0,141,0,
152,0,155,0,160,0,164,0,176,0,197,0,218,0,220,0,
223,0,240,255,48,0,228,117,224,0,226,0,228,0,231,0,
233,0,234,0,235,0,237,0,239,0,242,0,244,0,246,0,
252,0,254,0,255,0,0,124,253,255,64,0,183,114,0,255,
138,141,130,0,240,255,72,0,25,114,188,2,27,9,251,12,
252,12,90,12,106,12,123,12,68,11,153,3,160,4,43,1,
62,1,28,12,240,11,85,11,91,9,240,255,88,0,5,146,
147,11,148,10,129,11,103,11,76,1,249,6,0,9,120,11,
114,5,70,2,59,11,193,1,117,7,32,2,145,3,13,2,
246,255,104,0,135,219,194,7,132,2,134,0,3,2,121,1,
36,11,121,2,82,3,128,3,100,1,240,255,138,0,2,34,
0,0,0,0,0,0,0,0,224,48,224,16,147,0,228,48,
228,16,144,210,0,42,3,170,192,170,62,48,0,183,216,32,
241,255,154,0,191,161,41,40,5,130,12,181,0,3,255,3,
45,32,245,40,26,197,26,205,0,3,0,181,1,3,127,96,
167,0,0,0,240,255,170,0,85,179,251,0,249,0,241,0,
248,0,232,0,250,0,23,11,27,11,15,11,19,11,156,10,
91,2,173,10,90,2,0,0,0,0,240,255,186,0,113,129,
0,0,0,0,0,0,0,0,0,0,0,0,29,15,87,15,
88,15,126,15,152,15,158,15,160,15,171,15,253,0,29,1,
243,255,202,0,140,172,60,1,29,15,29,15,86,15,87,15,
112,1,80,2,12,2,15,2,183,12,2,0,0,0,0,0,
240,255,232,0,143,187,174,0,162,0,188,190,190,0,190,189,
189,0,188,189,188,0,187,0,172,0,168,0,219,0,172,0,
192,0,169,0,221,0,249,255,248,0,128,251,173,0,171,0,
175,0,170,0,222,0,0,0,0,0,240,255,63,1,18,86,
6,33,43,40,26,197,26,204,0,3,1,3,185,0,67,64,
68,72,69,80,70,88,112,133,71,64,255,103,16,1,200,103,
240,255,79,1,175,47,82,1,201,103,24,1,63,99,4,130,
63,102,71,32,128,130,67,32,68,40,69,48,70,56,127,96,
0,4,0,32,5,65,240,255,95,1,144,191,3,33,0,64,
63,102,113,4,0,0,255,33,0,64,0,133,231,64,237,1,
137,96,231,32,5,130,92,4,229,48,229,16,240,255,111,1,
65,149,147,8,231,80,5,210,3,1,19,9,92,4,218,40,
5,204,72,96,92,4,73,103,255,1,229,64,231,88,216,64,
0,146,240,255,127,1,154,244,147,8,229,16,191,96,4,9,
231,56,127,96,0,3,21,89,220,32,214,40,26,140,9,1,
17,81,38,48,16,9,37,48,240,255,143,1,24,68,14,9,
12,49,0,133,220,64,41,40,27,204,220,16,37,40,5,205,
220,72,4,9,1,5,0,0,0,0,73,103,255,1,240,255,
159,1,121,28,73,114,0,3,136,97,62,40,13,141,211,1,
35,40,13,143,0,166,37,48,13,165,205,1,13,197,203,1,
40,40,218,48,240,255,175,1,246,234,1,9,0,222,2,7,
183,1,210,1,76,1,201,1,199,1,12,141,166,0,7,9,
138,141,170,138,197,210,196,193,141,217,248,255,191,1,201,148,
0,138,81,226,66,32,183,9,80,133,218,64,102,12,166,0,
240,255,199,1,8,66,12,141,92,4,4,141,5,1,230,72,
0,172,217,72,92,4,230,40,5,170,92,4,40,40,13,165,
6,1,39,40,12,141,240,255,215,1,110,21,9,1,46,48,
173,9,218,48,0,173,13,180,228,1,102,12,92,4,35,40,
13,164,15,1,36,48,195,40,80,170,228,56,240,255,231,1,
52,189,26,189,7,1,43,9,38,48,13,149,14,1,72,96,
0,146,151,9,92,4,228,32,36,48,194,40,80,170,26,141,
249,1,240,255,247,1,140,137,228,24,47,32,241,1,218,32,
0,173,5,164,3,1,230,72,92,4,218,16,1,5,201,2,
0,242,117,9,102,12,230,88,240,255,7,2,251,251,72,96,
230,32,4,130,254,1,0,2,1,213,62,32,1,199,41,32,
215,64,229,48,229,16,3,1,228,48,228,16,9,89,240,255,
23,2,159,243,64,56,144,210,0,42,2,239,1,142,192,138,
0,74,1,5,0,0,125,88,63,32,80,170,80,170,32,48,
124,80,206,48,240,255,39,2,115,119,35,56,13,239,4,1,
144,250,13,239,0,171,80,252,0,246,205,56,26,220,10,1,
1,58,74,250,0,159,13,237,12,1,240,255,55,2,189,4,
124,24,245,1,181,12,6,0,204,32,27,197,3,1,181,12,
23,0,1,74,205,80,252,48,124,32,0,149,125,4,119,88,
240,255,71,2,66,211,210,12,245,48,103,12,225,48,1,42,
0,133,74,12,208,12,119,4,126,88,38,48,103,12,37,48,
103,12,209,12,126,4,240,255,87,2,123,207,0,0,0,0,
210,197,1,173,0,172,251,73,251,89,110,12,191,96,194,48,
65,40,0,74,0,219,245,49,0,83,80,251,240,255,103,2,
142,47,229,88,103,12,239,45,0,133,74,12,218,48,17,40,
13,205,215,9,0,213,103,12,194,48,80,194,108,12,127,96,
99,56,240,255,119,2,1,137,224,17,93,56,231,32,4,130,
254,1,0,3,80,210,80,214,121,40,192,170,80,182,80,210,
0,3,4,210,122,80,123,88,240,255,135,2,163,77,121,72,
125,72,111,40,0,166,124,64,4,210,47,9,122,40,0,206,
122,72,124,36,109,165,5,1,124,16,121,24,251,1,240,255,
151,2,131,120,123,4,123,16,90,130,23,1,124,48,41,34,
125,64,30,9,125,40,109,205,16,1,121,80,25,9,217,9,
125,40,109,205,240,255,167,2,227,231,10,1,121,80,19,9,
121,40,0,182,125,40,109,205,3,1,181,12,7,0,124,48,
111,40,0,181,125,32,27,40,75,130,240,255,183,2,197,71,
123,4,0,182,103,12,1,5,205,3,126,88,145,8,159,8,
1,130,126,4,181,12,8,0,240,32,12,149,252,1,2,49,
240,255,199,2,183,4,37,1,92,0,82,48,253,80,80,133,
0,66,0,133,168,64,216,64,206,48,255,66,102,12,62,40,
80,170,229,72,76,12,240,255,215,2,140,77,0,173,254,72,
38,56,5,221,81,4,159,8,230,1,121,80,221,9,157,9,
125,41,93,181,19,1,22,32,26,40,158,9,240,255,231,2,
228,67,92,1,23,56,26,221,70,1,0,182,103,12,215,48,
30,40,13,204,47,1,13,205,16,1,13,180,5,1,80,4,
91,49,240,255,247,2,83,22,1,5,221,3,216,80,145,8,
38,40,13,181,3,1,103,12,251,1,0,213,45,1,62,40,
16,72,78,12,14,1,16,68,240,255,7,3,55,172,16,76,
255,16,16,32,83,40,27,140,4,1,244,32,13,149,245,1,
38,32,13,149,3,1,181,12,0,0,16,32,80,131,240,255,
23,3,29,184,229,64,102,5,244,32,12,149,245,1,0,133,
0,138,232,1,157,9,192,210,121,80,145,8,207,8,5,1,
121,40,0,206,240,255,39,3,43,117,121,72,145,8,38,32,
12,149,232,1,121,40,101,12,103,12,79,5,13,221,145,133,
0,133,160,130,123,64,76,12,1,130,240,255,55,3,20,27,
3,1,181,12,13,0,123,32,0,166,255,64,229,16,229,16,
38,56,12,221,210,1,60,5,0,133,19,40,0,213,105,12,
245,255,71,3,188,175,18,48,2,9,9,0,0,246,3,6,
173,6,171,5,91,2,142,6,91,2,76,0,240,255,82,3,
120,49,174,202,51,49,0,0,183,184,0,0,192,153,224,209,
34,208,133,78,5,81,244,29,243,29,192,164,0,0,44,12,
143,78,240,255,98,3,144,124,166,144,196,149,180,72,242,153,
184,56,52,16,173,200,180,176,0,0,45,145,179,72,208,37,
73,66,161,72,212,165,83,132,240,255,114,3,196,152,238,204,
196,201,50,206,231,177,16,151,46,205,243,141,142,134,46,208,
0,0,20,0,0,0,14,4,0,0,0,0,0,0,240,255,
130,3,213,20,0,0,16,0,14,0,15,0,64,84,134,4,
136,4,12,0,16,128,84,4,44,4,78,214,125,2,20,0,
1,0,194,40,240,255,146,3,242,169,80,170,228,72,0,3,
242,209,128,86,128,58,4,0,77,12,20,1,121,80,5,130,
14,1,229,48,144,210,0,211,0,66,240,255,162,3,38,250,
0,211,0,74,80,211,122,80,34,48,103,12,122,32,229,64,
3,1,0,178,103,12,121,48,159,8,2,1,32,1,242,40,
240,255,178,3,232,212,13,181,105,1,243,40,13,181,102,1,
247,40,13,181,211,5,246,40,13,181,208,5,26,205,7,1,
235,40,26,205,202,5,240,255,194,3,9,171,252,40,13,181,
195,5,233,40,13,181,193,5,38,40,13,181,3,9,181,12,
1,0,49,48,103,12,52,1,121,80,145,8,240,255,210,3,
235,244,159,8,2,1,12,1,207,8,1,213,2,1,228,24,
121,40,192,170,0,206,101,12,103,12,187,1,19,3,174,13,
111,56,240,255,226,3,174,237,5,43,93,181,78,1,6,43,
93,181,99,1,21,32,18,40,105,12,97,1,22,40,12,181,
0,211,247,32,0,150,0,142,240,255,242,3,162,198,12,181,
234,1,229,40,144,170,121,72,51,48,103,12,76,12,229,5,
121,16,121,76,38,40,12,181,224,5,121,40,80,171,240,255,
2,4,46,187,229,72,253,48,82,32,5,197,3,1,181,12,
10,0,0,42,13,140,3,1,181,12,11,0,254,40,4,170,
81,12,194,48,240,255,18,4,225,111,62,32,229,40,144,171,
96,12,194,56,0,133,218,64,217,64,1,5,19,7,57,48,
215,40,35,32,26,165,4,1,48,32,240,255,34,4,169,33,
26,164,4,1,253,20,184,1,230,1,253,16,80,173,253,76,
0,211,178,1,59,48,253,28,175,1,253,24,0,211,172,1,
240,255,50,4,230,238,72,12,27,40,0,182,215,40,29,56,
12,188,165,1,103,12,145,8,242,40,12,181,162,5,72,12,
192,194,80,134,0,182,240,255,66,4,66,252,206,56,255,67,
103,12,145,8,246,40,12,181,151,5,80,4,50,48,146,1,
56,33,25,40,0,213,105,12,69,1,27,40,240,255,82,4,
108,229,0,182,138,1,49,33,27,197,17,1,12,149,3,1,
181,12,1,0,0,50,172,32,4,197,245,1,253,44,12,140,
248,1,240,255,98,4,235,126,253,32,82,40,12,141,58,48,
237,1,0,202,53,48,237,32,215,56,12,140,6,1,56,32,
13,157,15,1,0,211,226,1,240,255,114,4,38,181,0,211,
0,211,12,141,11,1,54,32,13,157,6,1,0,211,56,32,
12,157,215,1,0,211,229,24,212,1,56,48,12,164,240,255,
130,4,255,158,0,211,208,1,30,0,186,0,60,48,204,1,
52,48,216,80,103,12,145,8,38,40,13,181,186,1,233,40,
12,181,249,1,240,255,146,4,108,6,0,213,216,80,191,1,
80,172,216,72,228,24,228,24,145,8,12,181,216,16,251,1,
192,202,1,5,220,3,121,88,5,170,240,255,162,4,119,49,
99,4,229,32,0,129,144,128,122,64,193,32,206,48,203,56,
0,90,1,58,26,196,26,236,10,1,0,211,0,211,12,237,
240,255,178,4,10,253,249,1,121,32,5,130,18,1,0,173,
7,1,121,32,4,130,3,1,181,12,13,0,80,172,122,56,
61,32,0,157,123,88,240,255,194,4,47,111,5,170,6,1,
0,133,0,58,8,1,123,64,80,139,80,252,0,246,0,34,
2,58,0,229,121,72,125,80,126,88,123,48,240,255,210,4,
238,224,0,149,124,80,204,40,0,182,205,32,26,196,3,1,
181,12,14,0,204,80,203,32,124,48,0,198,203,64,125,36,
0,150,240,255,226,4,82,182,96,12,124,32,75,130,7,1,
204,48,0,173,0,74,0,211,4,131,253,1,205,48,125,56,
124,40,0,211,0,211,27,221,240,255,242,4,149,189,7,1,
0,34,5,130,250,1,0,166,0,66,247,1,121,48,206,40,
0,206,206,72,205,32,125,40,0,150,205,80,96,12,240,255,
2,5,31,232,121,32,75,129,5,1,205,48,0,173,0,74,
255,74,5,130,8,1,75,130,10,1,125,48,126,32,0,66,
254,32,255,66,240,255,18,5,13,9,62,32,122,40,126,48,
96,12,126,32,80,172,80,165,124,40,80,170,195,56,0,51,
26,196,10,1,12,197,5,1,121,48,240,255,34,5,201,118,
75,210,3,1,0,51,1,182,0,213,0,83,0,251,196,48,
26,245,241,1,197,48,227,56,80,133,123,64,122,88,26,245,
240,255,50,5,142,218,31,1,0,42,125,32,26,140,24,1,
12,141,19,1,121,32,74,130,19,1,0,234,126,80,123,56,
0,194,0,230,148,250,240,255,66,5,197,28,0,252,0,230,
0,246,96,12,126,48,122,56,123,32,0,157,230,1,121,32,
0,142,0,74,123,32,0,150,225,1,123,32,240,255,82,5,
101,182,148,130,7,1,227,88,198,48,0,211,226,56,20,32,
214,1,226,88,223,32,125,40,26,164,99,4,12,141,9,1,
121,48,240,255,98,5,34,68,74,210,99,4,223,16,223,16,
2,13,99,4,199,6,121,40,0,142,221,32,223,72,124,40,
0,142,4,130,221,72,99,4,240,255,114,5,108,198,13,149,
0,3,120,88,27,149,13,1,0,186,0,149,0,182,0,43,
0,74,13,157,120,4,0,249,0,248,0,209,0,208,247,255,
130,5,16,104,248,1,0,154,0,35,0,66,13,189,120,4,
0,251,0,211,250,1,240,255,139,5,241,239,120,88,121,80,
210,12,121,48,111,56,0,246,0,34,82,130,1,173,41,42,
80,170,121,72,19,49,80,130,67,210,254,1,240,255,155,5,
85,129,122,64,103,12,122,32,4,130,248,1,121,32,149,146,
6,1,245,40,27,205,238,1,0,182,103,12,210,12,120,4,
6,8,240,255,171,5,253,144,193,48,18,32,218,64,127,96,
254,40,4,170,100,12,225,80,216,80,0,133,217,64,123,64,
126,64,110,12,217,32,4,130,240,255,187,5,218,60,99,4,
194,48,65,32,0,66,80,195,229,64,225,32,206,40,26,141,
99,4,225,36,80,130,224,64,225,24,225,44,225,24,240,255,
203,5,97,28,0,133,75,12,142,8,124,80,30,40,123,56,
4,204,5,1,4,250,0,188,123,88,3,1,149,170,123,16,
85,250,6,1,240,255,219,5,60,37,125,88,210,12,125,24,
254,1,124,48,35,40,12,183,63,1,144,170,0,181,166,9,
124,48,30,40,13,204,91,1,13,181,240,255,235,5,237,27,
108,1,13,180,37,1,29,40,0,132,13,204,126,64,142,8,
28,32,27,149,63,5,31,40,26,205,120,1,34,32,27,149,
240,255,251,5,139,181,56,5,13,149,123,1,48,32,27,149,
54,1,0,139,13,180,103,1,51,40,26,205,47,5,0,50,
121,80,103,12,121,40,240,255,11,6,209,96,192,178,66,170,
103,12,215,32,233,56,4,157,225,1,121,88,142,8,35,40,
26,204,3,1,103,12,251,1,121,40,4,170,240,255,27,6,
45,239,79,1,233,48,103,12,212,1,224,16,0,173,22,56,
144,170,5,183,1,242,0,243,103,13,224,48,144,210,121,80,
121,44,240,255,43,6,131,66,6,33,0,143,0,133,121,16,
74,12,58,1,255,63,184,5,137,6,130,6,133,6,126,16,
12,1,126,80,192,210,80,214,240,255,59,6,106,49,206,56,
255,83,242,48,103,12,126,48,103,12,246,48,219,1,1,253,
142,8,121,88,94,12,63,56,74,130,0,231,160,130,240,255,
75,6,41,122,160,130,192,146,122,64,103,12,122,48,35,40,
12,183,103,12,121,40,4,170,21,1,156,1,142,8,5,210,
17,1,121,80,240,255,91,6,229,223,224,48,144,210,122,80,
122,36,122,16,122,44,122,16,74,12,229,24,121,24,2,1,
4,1,244,48,103,12,245,1,0,213,240,255,107,6,185,217,
103,12,194,48,80,194,108,12,195,5,124,80,19,48,27,13,
229,24,124,48,35,40,0,182,166,1,224,56,144,251,0,35,
240,255,123,6,166,73,0,251,0,43,80,251,224,88,75,12,
229,24,213,1,0,202,0,133,251,1,13,181,153,1,252,40,
2,1,27,40,0,181,240,255,139,6,68,134,2,13,202,1,
139,5,192,48,203,80,204,80,193,40,223,72,206,72,7,9,
221,64,193,40,80,132,0,142,205,72,99,4,240,255,155,6,
200,47,193,32,225,64,197,32,227,64,198,32,226,64,0,133,
0,66,0,211,26,205,253,1,195,48,199,40,0,66,0,211,
26,205,240,255,171,6,244,225,253,1,0,3,203,48,204,80,
205,40,235,9,217,64,205,40,206,48,63,32,26,205,11,1,
255,58,75,250,3,1,0,159,240,255,187,6,4,91,255,90,
0,253,0,90,80,252,0,246,245,1,66,32,108,12,193,40,
223,72,2,9,51,1,0,173,221,72,206,40,223,48,240,255,
203,6,155,7,26,205,0,3,0,50,223,24,223,24,0,203,
221,72,0,42,62,32,0,167,192,141,30,48,12,181,239,1,
222,64,0,3,240,255,219,6,134,57,221,40,5,170,234,9,
221,40,4,170,3,1,181,12,15,0,87,12,115,88,202,56,
26,220,211,0,221,44,0,74,221,16,240,255,235,6,100,226,
221,44,1,74,221,16,0,133,222,24,2,1,221,64,115,40,
172,56,13,189,230,1,49,56,12,189,211,0,127,96,168,56,
240,255,251,6,111,255,0,173,168,72,218,32,5,250,7,1,
17,40,2,9,16,0,4,141,181,4,183,4,99,56,5,130,
110,4,225,56,206,40,240,255,11,7,62,223,26,237,45,5,
0,59,225,24,225,24,217,32,4,130,104,4,196,40,219,72,
218,32,17,40,13,141,4,1,4,130,218,72,240,255,27,7,
108,254,127,96,0,133,230,64,216,72,0,43,82,170,37,1,
80,250,224,88,142,8,218,32,4,130,9,1,31,32,13,148,
4,1,240,255,43,7,147,213,30,32,27,197,3,1,181,12,
12,0,2,9,35,0,0,246,183,6,128,7,91,2,91,2,
194,7,103,7,189,7,93,7,245,255,59,7,2,170,103,8,
211,8,249,6,249,6,211,7,91,2,178,7,195,6,64,8,
228,7,219,6,240,255,70,7,115,59,83,162,16,1,218,56,
4,250,3,1,181,12,12,0,227,56,198,48,27,221,3,1,
181,12,18,0,225,40,0,75,227,16,240,255,86,7,124,66,
144,138,144,170,100,12,225,80,17,40,218,72,157,1,227,48,
197,32,27,197,3,1,181,12,19,0,227,24,255,42,225,72,
240,255,102,7,43,182,147,1,142,8,195,40,0,182,115,80,
224,16,142,8,55,56,12,221,211,0,224,40,115,48,191,74,
93,4,116,0,193,48,240,255,118,7,78,206,255,34,13,141,
0,3,80,132,0,150,206,32,26,149,249,1,181,12,13,0,
87,12,5,210,211,0,116,64,117,72,53,48,240,255,134,7,
53,120,115,80,26,244,12,1,56,48,27,245,9,1,115,88,
87,12,5,210,211,0,118,88,227,49,176,12,118,56,51,48,
12,221,240,255,150,7,1,21,211,0,115,48,4,130,11,1,
55,56,12,221,13,220,3,1,12,244,93,4,224,48,144,211,
0,42,181,1,54,56,13,220,240,255,166,7,75,241,250,1,
138,170,5,1,12,245,13,244,245,1,93,4,56,56,12,245,
13,220,240,1,93,4,10,13,73,12,142,8,172,56,240,255,
182,7,75,143,13,221,251,1,49,56,13,221,93,4,211,0,
92,9,110,12,1,5,185,1,212,211,208,207,110,12,194,48,
65,40,0,74,240,255,198,7,196,194,250,41,1,74,249,41,
2,74,17,40,80,206,229,72,97,12,194,48,80,194,108,12,
110,12,99,4,87,12,55,40,12,189,240,255,214,7,142,190,
211,0,115,80,202,56,26,220,211,0,87,12,4,210,49,48,
12,221,211,0,115,48,0,66,1,74,93,4,0,213,115,80,
240,255,230,7,152,239,110,12,194,48,0,214,229,80,87,12,
4,210,15,1,52,48,13,221,60,1,50,48,13,220,64,1,
115,32,115,88,49,48,240,255,246,7,71,180,12,221,10,1,
4,130,93,4,12,1,115,88,74,12,115,56,52,48,13,244,
211,0,172,48,13,221,21,1,49,48,13,221,240,255,6,8,
104,131,208,12,209,12,194,48,80,194,108,12,99,56,218,32,
5,130,110,4,115,56,49,48,13,245,93,4,172,48,12,245,
13,244,240,255,22,8,116,177,208,1,211,0,220,48,229,40,
0,206,194,48,80,210,0,205,213,48,4,205,4,1,13,157,
253,1,228,1,75,170,250,1,240,255,38,8,142,26,116,72,
210,12,116,16,254,1,221,1,142,8,5,210,3,1,103,12,
252,1,115,80,185,1,87,12,5,210,211,0,115,88,240,255,
54,8,216,198,89,12,214,48,18,205,255,1,0,182,220,40,
0,205,75,170,191,1,231,1,87,12,115,80,116,88,202,56,
26,220,211,0,240,255,70,8,104,139,110,12,3,9,191,220,
0,160,96,226,108,12,107,12,102,12,217,56,4,250,104,4,
0,253,216,88,78,12,4,1,38,56,240,255,86,8,190,104,
13,221,4,1,2,33,242,1,144,16,115,56,0,67,1,75,
116,48,172,56,216,88,13,221,222,1,49,56,12,221,211,0,
240,255,102,8,69,130,93,4,142,8,226,32,198,56,27,228,
18,1,0,43,13,205,4,1,20,40,0,190,249,1,115,80,
0,242,20,32,0,230,240,255,118,8,156,32,226,40,96,12,
20,32,226,56,0,157,226,88,115,48,226,56,199,40,26,236,
3,1,181,12,20,0,0,83,225,40,1,75,240,255,134,8,
5,222,224,24,87,12,115,80,55,32,202,40,27,204,12,229,
211,0,87,12,4,210,50,48,12,221,211,0,115,48,0,66,
1,74,240,255,150,8,142,205,87,12,5,210,211,0,226,48,
2,66,3,74,51,48,13,244,5,1,144,133,35,40,80,171,
2,1,87,12,4,210,49,48,240,255,166,8,130,57,12,221,
211,0,226,48,4,66,5,74,115,56,0,35,1,43,0,211,
0,211,176,12,226,56,5,51,138,210,7,1,130,170,240,255,
182,8,152,83,8,1,20,48,0,222,226,88,93,4,4,130,
130,170,250,1,225,48,206,40,27,205,3,1,181,12,21,0,
0,42,80,170,240,255,198,8,96,14,224,72,80,252,0,246,
225,80,142,8,30,40,12,204,241,1,142,8,226,44,12,181,
237,1,93,4,142,8,226,56,250,43,240,255,214,8,213,235,
13,205,10,1,20,40,0,189,198,40,27,237,3,1,181,12,
22,0,226,88,245,1,94,12,115,80,0,34,1,42,226,48,
240,255,230,8,31,100,80,252,0,246,177,12,115,48,0,66,
1,74,226,48,18,56,0,245,176,12,226,56,255,51,131,210,
8,1,4,130,130,170,246,255,246,8,4,142,7,1,20,40,
0,189,226,88,93,4,130,170,251,1,251,43,225,72,93,4,
240,255,0,9,251,58,34,40,96,207,206,48,0,181,0,34,
0,202,1,50,74,130,0,211,0,3,119,88,205,56,80,212,
0,222,204,48,26,244,240,255,16,9,55,106,7,1,0,186,
1,83,0,219,0,251,204,88,119,4,181,12,23,0,255,131,
255,3,115,64,116,72,117,88,62,56,26,157,240,255,32,9,
132,150,27,189,12,1,5,170,12,1,0,155,146,170,0,230,
80,250,4,170,252,1,240,57,26,157,3,1,183,12,24,0,
118,64,240,255,48,9,96,106,208,9,5,210,18,1,74,130,
3,1,183,12,25,0,227,57,0,231,118,56,26,229,3,1,
183,12,28,0,115,40,192,170,240,255,64,9,85,155,116,56,
0,238,255,74,117,4,198,9,0,211,119,72,210,41,13,143,
3,1,183,12,26,0,118,40,96,170,0,238,205,56,240,255,
80,9,178,55,27,189,198,1,204,72,115,40,138,130,237,1,
118,56,64,230,160,130,119,68,228,1,1,173,0,172,139,72,
114,88,200,40,240,255,96,9,165,85,140,72,201,40,141,72,
48,48,140,84,140,16,140,32,201,40,27,140,93,1,142,8,
140,84,48,32,27,196,35,1,140,56,240,255,112,9,55,31,
255,43,26,164,211,0,62,32,26,141,211,0,35,32,27,196,
237,1,27,32,27,197,10,1,0,202,0,133,90,12,141,48,
240,255,128,9,39,131,0,66,1,74,141,16,141,16,224,1,
34,32,5,197,4,1,140,16,61,48,218,1,224,40,144,179,
0,203,80,171,224,72,240,255,144,9,54,227,212,1,140,56,
255,43,57,32,12,149,14,1,62,56,27,164,27,189,6,1,
59,32,12,141,13,140,211,0,199,1,48,32,240,255,160,9,
63,219,12,141,211,0,195,1,35,32,26,164,4,1,48,32,
26,164,36,1,62,32,27,165,49,1,57,32,12,141,13,140,
4,1,240,255,176,9,121,118,48,32,12,141,211,0,173,32,
12,149,5,1,112,32,140,68,140,16,171,1,13,148,175,1,
140,48,200,40,4,180,211,0,240,255,192,9,173,225,140,60,
172,32,27,229,211,0,114,4,10,9,181,12,29,0,0,133,
0,173,224,24,114,4,57,32,13,148,151,1,0,178,240,255,
208,9,240,141,139,32,5,130,5,1,200,32,0,131,13,156,
242,1,94,12,5,210,236,13,140,56,255,83,140,56,0,35,
254,43,144,130,240,255,224,9,66,62,144,170,27,141,46,1,
33,32,27,141,211,0,255,51,0,34,1,42,253,51,254,59,
184,15,140,56,254,67,202,32,255,51,240,255,240,9,113,195,
26,196,26,220,8,1,253,51,26,196,26,220,8,1,141,24,
141,24,5,1,253,51,26,196,26,220,13,1,141,48,80,132,
240,255,0,10,189,136,0,150,254,35,0,66,1,74,253,83,
0,51,254,83,140,24,140,24,211,1,141,48,27,196,186,1,
141,16,141,16,242,1,240,255,16,10,169,116,0,43,173,32,
26,141,187,1,59,32,12,141,9,1,254,43,57,32,12,141,
15,1,255,43,254,75,140,24,157,1,13,140,240,255,32,10,
62,16,20,1,58,32,12,141,6,1,254,43,13,164,168,1,
183,12,4,0,219,32,196,40,27,141,42,1,255,51,0,34,
1,42,240,255,48,10,218,92,0,59,139,16,114,4,211,0,
254,43,58,32,13,141,4,1,0,133,0,67,8,1,255,51,
0,34,1,42,89,12,140,24,240,255,64,10,243,9,140,24,
140,76,140,24,140,52,0,34,1,42,89,12,140,76,140,24,
140,24,140,52,139,40,5,170,5,1,140,56,2,35,240,255,
80,10,97,178,3,43,114,4,94,12,74,130,38,1,30,1,
0,43,49,32,12,141,24,1,219,48,17,32,0,149,219,80,
2,42,224,72,240,255,96,10,50,89,0,149,206,84,140,24,
140,56,0,51,202,32,26,196,26,220,3,1,253,83,157,1,
254,43,0,75,0,42,254,75,1,42,240,255,112,10,184,7,
154,1,181,12,30,0,22,32,140,56,3,43,0,51,4,170,
0,138,73,12,62,40,140,84,255,50,192,194,0,167,0,207,
240,255,128,10,189,217,140,56,2,51,27,197,4,1,3,35,
26,141,3,1,181,12,31,0,0,171,146,170,0,198,80,210,
4,170,252,1,80,146,252,255,144,10,15,6,0,43,0,182,
1,5,100,9,240,255,148,10,163,144,138,88,88,12,5,130,
74,170,2,1,138,4,183,12,31,0,13,65,13,73,13,89,
0,34,1,42,5,130,0,3,25,13,240,255,164,10,152,19,
4,49,179,12,23,13,4,5,169,10,0,0,0,0,0,0,
104,0,138,88,31,56,26,221,22,1,251,57,26,221,3,1,
240,255,180,10,114,37,183,12,39,0,12,9,230,10,233,10,
236,10,243,10,233,13,7,14,59,14,212,14,7,15,158,14,
12,15,0,246,162,50,240,255,196,10,103,177,138,56,0,2,
140,56,253,35,195,48,0,150,191,34,4,130,3,1,183,12,
32,0,219,48,197,40,26,204,3,1,181,12,240,255,212,10,
20,96,33,0,224,40,2,74,224,64,0,35,254,67,140,24,
255,59,0,35,0,66,1,35,1,66,206,84,17,32,0,150,
219,80,240,255,228,10,185,102,1,5,99,9,88,12,90,12,
138,4,80,212,0,207,0,3,5,130,0,3,144,133,35,48,
128,170,64,203,0,3,11,9,240,255,244,10,23,209,188,64,
9,9,189,64,0,133,191,64,35,32,190,64,90,9,63,9,
138,4,15,33,15,49,80,138,80,170,4,211,254,1,240,255,
4,11,222,91,0,142,80,170,80,170,0,166,4,41,0,166,
3,65,0,3,25,54,0,0,248,255,129,88,20,9,84,12,
12,1,129,88,240,255,20,11,203,200,16,9,85,12,8,1,
129,88,12,9,9,13,4,1,129,88,8,9,6,13,55,9,
37,9,27,9,129,4,235,11,184,11,240,255,36,11,174,60,
188,64,130,88,0,162,19,57,0,231,189,64,0,34,184,64,
1,34,0,146,0,231,185,64,0,248,144,239,190,72,112,173,
240,255,52,11,81,223,191,72,144,247,186,80,112,213,187,80,
130,4,0,254,255,33,189,40,144,143,190,32,80,142,191,32,
0,142,188,32,0,3,240,255,68,11,204,128,190,32,62,40,
26,141,0,3,67,130,5,1,0,133,0,173,0,213,3,1,
168,16,1,212,191,64,190,72,188,80,189,80,240,255,84,11,
38,42,0,3,188,32,189,40,5,130,4,170,4,1,190,64,
191,64,0,3,74,130,6,1,80,170,64,130,190,24,251,1,
250,1,240,255,100,11,180,94,188,64,189,72,0,3,184,48,
188,40,188,80,184,72,185,48,189,40,189,80,185,72,186,48,
190,40,186,72,190,80,187,48,243,255,116,11,116,97,191,40,
187,72,191,80,0,3,0,42,184,72,1,42,185,72,2,42,
186,72,3,42,187,72,0,3,240,255,129,11,145,15,17,89,
41,48,190,80,0,213,191,80,75,130,5,1,191,16,4,169,
1,128,0,129,188,64,189,72,86,12,98,12,2,5,240,255,
145,11,17,198,0,0,0,0,255,89,109,12,0,133,0,138,
190,48,35,56,18,245,5,210,12,1,245,81,188,48,189,56,
80,250,64,210,240,255,161,11,105,124,64,170,64,130,74,130,
12,1,236,25,249,1,191,24,234,5,5,250,4,210,9,1,
4,169,1,128,0,129,227,5,168,16,240,255,177,11,179,238,
0,172,144,132,244,1,18,171,0,131,246,1,24,0,130,88,
186,32,190,40,13,141,15,1,19,165,1,129,91,12,131,64,
240,255,193,11,145,229,246,41,27,140,130,4,184,32,185,40,
144,130,128,170,131,24,253,1,3,1,184,32,185,40,187,48,
191,56,128,222,188,48,240,255,209,11,93,33,189,56,3,130,
16,1,19,189,33,148,32,149,3,130,8,1,4,249,1,208,
0,209,186,32,190,64,187,32,191,64,188,80,240,255,225,11,
116,202,189,88,130,4,18,190,16,211,3,150,250,1,190,16,
160,210,128,250,246,1,191,32,128,130,64,133,191,64,201,1,
130,88,240,255,241,11,22,102,190,32,35,40,30,9,189,48,
185,40,17,9,184,40,16,9,189,64,0,162,188,48,185,40,
11,9,184,40,9,9,189,48,240,255,1,12,155,93,18,206,
0,131,188,64,189,72,130,4,240,255,48,133,131,88,253,57,
131,170,129,130,144,198,4,251,252,1,176,170,131,4,240,255,
17,12,43,202,0,165,186,40,0,166,190,64,187,32,191,40,
128,166,112,133,191,64,0,3,32,0,130,88,190,40,35,32,
242,9,190,16,240,255,33,12,229,197,184,32,185,40,144,130,
128,170,246,57,131,88,188,48,21,210,26,1,80,170,64,130,
188,48,189,56,11,197,4,1,13,197,240,255,49,12,197,231,
10,237,12,1,184,48,185,56,64,250,64,210,184,80,185,88,
131,24,240,1,188,80,189,88,130,4,19,237,17,196,16,197,
240,255,65,12,203,209,32,130,241,1,144,212,190,80,188,80,
130,4,0,0,255,89,188,32,189,40,80,170,64,130,80,170,
64,130,189,56,18,238,240,255,81,12,244,237,0,131,188,56,
0,230,80,170,64,130,48,17,1,1,239,5,16,39,0,242,
0,172,0,132,62,9,5,210,4,250,8,1,240,255,97,12,
164,248,88,12,247,49,5,130,26,205,3,1,4,170,23,1,
181,12,5,0,0,242,0,172,46,9,5,210,4,250,15,1,
127,64,240,255,113,12,60,255,128,72,88,12,27,48,5,130,
27,181,2,1,7,1,127,32,128,40,4,1,0,242,0,173,
29,9,11,57,4,250,24,17,240,255,129,12,4,5,6,49,
6,57,0,249,20,5,0,0,0,0,0,0,0,0,0,0,
139,12,0,160,0,0,132,0,0,0,144,12,204,204,250,255,
145,12,43,23,205,204,125,0,0,0,0,0,0,15,0,0,
240,255,154,12,130,115,44,32,249,65,253,73,251,81,249,89,
0,133,127,64,128,64,231,65,188,64,189,64,241,65,243,17,
2,1,8,1,145,8,240,255,170,12,2,120,244,40,13,204,
4,1,12,180,3,1,231,17,145,8,207,8,13,1,214,17,
0,181,188,32,223,41,4,143,248,1,143,9,240,255,186,12,
183,124,18,206,0,131,188,64,189,72,242,1,232,40,4,205,
7,1,127,40,4,170,4,1,193,73,127,16,233,1,191,81,
192,33,240,255,202,12,238,62,5,130,182,1,128,32,4,130,
19,1,199,33,191,64,127,32,5,130,3,1,178,33,0,129,
175,65,177,65,41,32,190,64,240,255,218,12,206,68,186,41,
4,181,12,1,91,12,128,16,0,133,195,1,189,40,163,33,
179,25,1,166,0,165,159,65,91,12,86,12,156,33,240,255,
234,12,160,4,165,49,74,130,1,129,157,49,5,130,7,1,
149,65,95,12,85,12,86,12,145,25,253,1,79,12,98,12,
128,48,143,57,255,255,250,12,106,237,157,5,240,255,251,12,
76,70,1,213,80,213,72,89,127,80,0,253,70,89,4,130,
13,1,4,170,5,1,210,12,43,48,103,12,116,1,188,64,
189,72,240,255,11,13,3,67,191,88,41,48,190,80,2,1,
109,12,127,56,191,40,41,48,4,170,248,48,5,250,103,12,
86,12,14,49,95,12,91,12,240,255,27,13,88,64,186,48,
33,56,26,221,9,1,35,56,26,221,10,1,36,17,1,1,
84,12,242,1,139,12,31,25,1,1,85,12,237,1,240,255,
43,13,242,40,184,32,185,40,90,57,13,221,6,1,144,130,
128,170,186,16,186,48,250,1,184,64,185,72,91,12,0,253,
127,88,76,13,240,255,59,13,160,147,189,72,71,49,127,56,
5,151,4,250,7,1,188,64,4,25,247,1,246,1,0,0,
0,0,0,197,188,64,57,33,0,150,240,255,75,13,56,97,
58,57,51,41,49,33,80,210,64,170,64,130,4,251,252,1,
43,65,43,73,127,16,127,48,20,56,26,220,225,1,188,48,
240,255,91,13,109,31,38,57,13,223,3,1,5,171,0,131,
127,48,21,56,27,221,8,1,127,16,32,49,80,170,64,130,
52,211,253,1,246,1,240,255,107,13,62,62,3,130,4,1,
217,17,1,1,21,33,14,65,14,73,22,57,0,239,0,231,
16,57,160,130,130,170,17,1,0,251,252,1,240,255,123,13,
64,211,58,9,210,12,200,5,0,0,0,0,0,0,0,8,
0,96,0,240,0,16,252,255,72,12,132,0,153,153,144,250,
144,250,240,255,139,13,14,236,0,225,186,49,21,56,19,40,
74,245,74,206,4,1,74,210,27,197,231,1,80,213,176,25,
1,1,29,9,44,48,103,12,240,255,155,13,170,189,249,48,
170,41,75,170,4,1,0,169,166,73,248,48,103,12,163,41,
22,48,0,133,27,205,4,1,0,205,0,131,252,1,240,255,
171,13,198,182,43,48,0,206,127,72,0,150,4,130,103,12,
127,48,103,12,201,1,0,0,255,89,20,56,201,89,0,253,
127,88,128,80,240,255,187,13,10,133,74,209,10,1,232,48,
103,12,128,48,5,210,5,1,0,211,128,80,43,48,249,1,
0,213,183,33,183,41,188,57,80,170,240,255,203,13,164,153,
64,130,64,210,4,251,252,1,175,65,175,73,20,56,27,220,
0,245,127,16,0,253,4,210,127,88,43,56,0,246,103,12,
243,255,219,13,246,164,128,24,5,1,80,213,127,80,232,48,
103,12,159,25,228,1,229,48,127,56,0,245,229,80,205,5,
240,255,232,13,172,27,0,0,5,130,0,3,253,89,146,186,
168,16,80,234,17,65,17,73,22,9,80,252,0,238,71,9,
13,65,13,73,7,49,248,255,248,13,106,155,178,12,6,49,
177,12,80,252,0,238,235,5,0,14,2,14,240,255,4,14,
245,202,5,14,114,177,0,23,138,88,139,170,5,130,22,1,
109,12,190,32,35,40,0,165,190,72,136,64,98,12,19,49,
103,9,240,255,20,14,136,19,134,64,135,72,136,40,74,170,
1,132,0,133,90,12,233,49,179,12,106,48,177,12,138,4,
1,172,80,172,0,132,168,16,240,255,36,14,106,248,138,4,
38,14,229,145,3,51,79,195,6,247,211,224,9,27,205,145,
10,121,252,236,9,133,151,135,8,155,57,179,5,25,240,255,
52,14,110,62,0,0,114,177,15,19,15,176,14,53,170,184,
2,59,138,88,134,64,135,72,106,48,246,33,246,41,176,12,
131,170,4,1,240,255,68,14,82,114,0,133,0,173,138,4,
106,48,239,33,239,41,176,12,131,170,213,1,236,33,236,41,
106,48,179,12,26,9,136,80,9,49,240,255,84,14,13,248,
38,9,109,12,190,32,136,40,0,166,190,64,98,12,138,4,
93,14,25,246,238,6,72,147,244,6,170,228,248,34,234,245,
240,255,100,14,85,65,252,210,114,177,0,123,255,255,0,255,
0,0,0,0,255,89,134,64,135,72,88,12,137,72,90,12,
106,48,176,12,137,48,254,255,116,14,152,235,246,5,0,0,
240,255,120,14,204,188,118,14,0,0,255,89,251,65,251,73,
0,34,1,42,246,81,245,17,244,17,243,53,5,210,245,5,
243,49,179,12,238,49,251,255,136,14,72,212,177,12,247,1,
0,0,0,0,141,14,240,255,143,14,16,230,0,0,250,89,
254,81,250,49,250,65,250,73,179,12,249,49,227,9,242,5,
242,89,246,9,241,49,179,12,238,5,144,170,240,255,159,14,
109,47,112,213,136,80,80,170,38,49,134,64,135,72,176,12,
128,170,134,32,135,40,112,213,137,80,131,210,3,1,27,49,
178,12,240,255,175,14,54,140,9,49,233,9,137,24,3,1,
24,49,176,12,136,48,0,206,138,4,185,14,213,128,244,98,
154,151,249,240,196,171,250,168,240,255,191,14,145,253,27,138,
253,218,150,203,252,26,161,170,255,186,255,255,0,245,0,0,
201,14,0,128,2,1,204,14,15,201,2,215,207,14,240,255,
207,14,69,51,249,162,2,131,210,14,249,162,0,131,138,88,
144,170,112,213,136,80,80,170,248,49,179,12,144,9,17,56,
0,223,136,48,240,255,223,14,125,64,148,250,0,211,136,80,
15,49,2,130,3,1,180,9,5,1,228,49,179,12,18,49,
166,9,136,48,128,210,112,213,4,130,240,255,239,14,225,221,
0,206,138,4,242,14,243,142,243,10,202,162,250,108,91,165,
1,21,15,201,2,207,0,0,252,14,58,194,226,174,149,181,
240,255,255,14,162,45,239,76,167,170,248,110,255,255,255,224,
255,255,0,255,0,0,138,88,195,49,177,12,203,1,0,0,
255,89,14,65,14,73,246,255,15,15,93,182,197,9,9,65,
9,73,9,33,9,41,243,9,3,49,178,12,244,5,25,15,
240,255,29,15,59,42,0,133,230,64,231,64,80,252,29,49,
0,34,0,90,0,42,0,66,12,189,5,1,23,41,0,182,
75,210,247,1,20,57,240,255,45,15,17,46,17,33,12,149,
18,57,0,193,0,128,11,49,0,43,5,170,13,1,0,165,
0,66,0,251,0,209,0,208,248,1,142,6,240,255,61,15,
155,253,199,0,0,16,0,8,132,15,141,15,1,35,121,64,
30,9,58,2,1,133,0,132,24,40,0,166,213,64,80,138,
80,170,240,255,77,15,192,143,0,166,214,64,121,16,11,1,
17,9,250,1,8,1,43,33,192,64,0,133,41,69,41,69,
41,69,41,69,5,33,2,64,240,255,93,15,125,184,4,33,
3,64,221,5,191,101,0,133,0,51,120,88,224,80,216,80,
142,8,5,210,5,1,73,114,137,103,255,1,250,1,240,255,
109,15,26,198,136,103,255,1,120,56,136,97,34,40,0,167,
73,98,137,103,255,1,7,41,13,165,1,3,5,41,12,141,
231,1,2,3,249,255,125,15,99,211,78,0,89,0,158,14,
119,3,120,3,121,3,122,3,240,255,253,0,101,164,10,13,
10,13,86,79,82,69,82,87,84,73,32,69,72,84,32,69,
85,70,67,78,73,84,78,79,32,83,73,83,44,78,240,255,
13,1,130,216,79,67,44,83,84,65,32,78,78,65,32,68,
65,84,32,78,84,40,80,89,32,69,32,89,82,79,78,32,
63,41,0,32,240,255,29,1,7,92,10,13,79,68,89,32,
85,79,87,32,83,73,32,72,79,67,77,77,39,65,32,83,
79,84,66,32,32,69,52,49,83,32,240,255,45,1,160,211,
65,80,69,67,32,83,84,40,80,89,32,69,41,89,32,44,
82,79,49,32,32,53,84,40,80,89,32,69,41,78,0,63,
240,255,132,15,14,239,20,0,17,0,3,0,6,0,26,0,
38,0,1,0,0,0,255,255,128,0,47,0,8,0,24,0,
26,0,38,0,1,0,254,255,148,15,110,240,0,0,0,0,
1,0,29,15,226,240,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36};

const unsigned char basic2tape[]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
248,255,0,0,25,40,2,0,99,1,3,4,58,15,231,64,
218,64,230,64,166,0,240,255,16,0,28,254,0,0,3,0,
4,0,5,0,6,0,7,0,10,0,11,0,15,0,18,0,
20,0,64,0,65,0,81,0,85,0,90,0,240,255,32,0,
248,245,94,0,124,0,127,0,128,0,135,0,138,0,141,0,
152,0,155,0,160,0,164,0,176,0,197,0,218,0,220,0,
223,0,240,255,48,0,228,117,224,0,226,0,228,0,231,0,
233,0,234,0,235,0,237,0,239,0,242,0,244,0,246,0,
252,0,254,0,255,0,0,124,253,255,64,0,183,114,0,255,
138,141,130,0,240,255,72,0,131,112,217,2,56,9,24,13,
25,13,119,12,135,12,152,12,97,11,182,3,189,4,43,1,
62,1,57,12,13,12,114,11,120,9,240,255,88,0,53,144,
176,11,177,10,158,11,132,11,105,1,22,7,29,9,149,11,
143,5,99,2,88,11,222,1,146,7,61,2,174,3,42,2,
246,255,104,0,130,218,223,7,161,2,134,0,32,2,150,1,
65,11,150,2,111,3,157,3,129,1,240,255,138,0,2,34,
0,0,0,0,0,0,0,0,224,48,224,16,147,0,228,48,
228,16,144,210,0,42,3,170,192,170,62,48,0,183,216,32,
241,255,154,0,191,161,41,40,5,130,12,181,0,3,255,3,
45,32,245,40,26,197,26,205,0,3,0,181,1,3,127,96,
167,0,0,0,240,255,170,0,109,178,251,0,249,0,241,0,
248,0,232,0,250,0,52,11,56,11,44,11,48,11,185,10,
120,2,202,10,119,2,0,0,0,0,240,255,186,0,84,129,
0,0,0,0,0,0,0,0,0,0,0,0,58,15,87,15,
88,15,126,15,152,15,158,15,160,15,171,15,253,0,29,1,
243,255,202,0,251,171,60,1,58,15,58,15,86,15,87,15,
112,1,109,2,41,2,44,2,183,12,2,0,0,0,0,0,
240,255,232,0,143,187,174,0,162,0,188,190,190,0,190,189,
189,0,188,189,188,0,187,0,172,0,168,0,219,0,172,0,
192,0,169,0,221,0,249,255,248,0,128,251,173,0,171,0,
175,0,170,0,222,0,0,0,0,0,240,255,63,1,122,237,
6,33,43,40,26,197,26,204,0,3,1,3,185,0,67,79,
80,89,82,73,71,72,84,32,40,67,41,32,49,57,54,57,
240,255,79,1,43,91,44,49,57,55,48,44,49,57,55,49,
44,49,57,55,50,44,49,57,55,51,65,76,76,32,82,73,
71,72,84,83,32,82,240,255,95,1,186,225,69,83,69,82,
86,69,68,0,67,64,68,72,69,80,70,88,112,133,71,64,
255,103,16,1,200,103,82,1,201,103,24,1,240,255,111,1,
128,210,63,99,4,130,63,102,71,32,128,130,67,32,68,40,
69,48,70,56,127,96,0,4,0,32,5,65,3,33,0,64,
63,102,240,255,127,1,51,91,113,4,0,0,255,33,0,64,
0,133,231,64,237,1,137,96,231,32,5,130,92,4,229,48,
229,16,147,8,231,80,5,210,240,255,143,1,105,70,3,1,
19,9,92,4,218,40,5,204,72,96,92,4,73,103,255,1,
229,64,231,88,216,64,0,146,147,8,229,16,191,96,240,255,
159,1,151,175,4,9,231,56,127,96,0,3,21,89,220,32,
214,40,26,140,9,1,17,81,38,48,16,9,37,48,14,9,
12,49,0,133,240,255,175,1,65,44,220,64,41,40,27,204,
220,16,37,40,5,205,220,72,4,9,1,5,0,0,0,0,
73,103,255,1,73,114,0,3,136,97,240,255,191,1,39,5,
62,40,13,141,211,1,35,40,13,143,0,166,37,48,13,165,
205,1,13,197,203,1,40,40,218,48,1,9,0,222,2,7,
240,255,207,1,181,75,212,1,239,1,105,1,230,1,228,1,
12,141,166,0,7,9,138,141,170,138,197,210,196,193,141,217,
0,138,81,226,66,32,251,255,223,1,57,33,183,9,80,133,
218,64,102,12,166,0,240,255,228,1,235,65,12,141,92,4,
4,141,5,1,230,72,0,172,217,72,92,4,230,40,5,170,
92,4,40,40,13,165,6,1,39,40,12,141,240,255,244,1,
81,21,9,1,46,48,173,9,218,48,0,173,13,180,228,1,
102,12,92,4,35,40,13,164,15,1,36,48,195,40,80,170,
228,56,240,255,4,2,23,189,26,189,7,1,43,9,38,48,
13,149,14,1,72,96,0,146,151,9,92,4,228,32,36,48,
194,40,80,170,26,141,249,1,240,255,20,2,82,137,228,24,
47,32,241,1,218,32,0,173,5,164,3,1,230,72,92,4,
218,16,1,5,230,2,0,242,117,9,102,12,230,88,240,255,
36,2,222,251,72,96,230,32,4,130,254,1,0,2,1,213,
62,32,1,199,41,32,215,64,229,48,229,16,3,1,228,48,
228,16,9,89,240,255,52,2,130,243,64,56,144,210,0,42,
2,239,1,142,192,138,0,74,1,5,0,0,125,88,63,32,
80,170,80,170,32,48,124,80,206,48,240,255,68,2,86,119,
35,56,13,239,4,1,144,250,13,239,0,171,80,252,0,246,
205,56,26,220,10,1,1,58,74,250,0,159,13,237,12,1,
240,255,84,2,160,4,124,24,245,1,181,12,6,0,204,32,
27,197,3,1,181,12,23,0,1,74,205,80,252,48,124,32,
0,149,125,4,119,88,240,255,100,2,37,211,210,12,245,48,
103,12,225,48,1,42,0,133,74,12,208,12,119,4,126,88,
38,48,103,12,37,48,103,12,209,12,126,4,240,255,116,2,
94,207,0,0,0,0,210,197,1,173,0,172,251,73,251,89,
110,12,191,96,194,48,65,40,0,74,0,219,245,49,0,83,
80,251,240,255,132,2,113,47,229,88,103,12,239,45,0,133,
74,12,218,48,17,40,13,205,215,9,0,213,103,12,194,48,
80,194,108,12,127,96,99,56,240,255,148,2,228,136,224,17,
93,56,231,32,4,130,254,1,0,3,80,210,80,214,121,40,
192,170,80,182,80,210,0,3,4,210,122,80,123,88,240,255,
164,2,134,77,121,72,125,72,111,40,0,166,124,64,4,210,
47,9,122,40,0,206,122,72,124,36,109,165,5,1,124,16,
121,24,251,1,240,255,180,2,102,120,123,4,123,16,90,130,
23,1,124,48,41,34,125,64,30,9,125,40,109,205,16,1,
121,80,25,9,217,9,125,40,109,205,240,255,196,2,198,231,
10,1,121,80,19,9,121,40,0,182,125,40,109,205,3,1,
181,12,7,0,124,48,111,40,0,181,125,32,27,40,75,130,
240,255,212,2,139,71,123,4,0,182,103,12,1,5,234,3,
126,88,145,8,159,8,1,130,126,4,181,12,8,0,240,32,
12,149,252,1,2,49,240,255,228,2,154,4,37,1,92,0,
82,48,253,80,80,133,0,66,0,133,168,64,216,64,206,48,
255,66,102,12,62,40,80,170,229,72,76,12,240,255,244,2,
111,77,0,173,254,72,38,56,5,221,81,4,159,8,230,1,
121,80,221,9,157,9,125,41,93,181,19,1,22,32,26,40,
158,9,240,255,4,3,199,67,92,1,23,56,26,221,70,1,
0,182,103,12,215,48,30,40,13,204,47,1,13,205,16,1,
13,180,5,1,80,4,91,49,240,255,20,3,25,22,1,5,
250,3,216,80,145,8,38,40,13,181,3,1,103,12,251,1,
0,213,45,1,62,40,16,72,78,12,14,1,16,68,240,255,
36,3,26,172,16,76,255,16,16,32,83,40,27,140,4,1,
244,32,13,149,245,1,38,32,13,149,3,1,181,12,0,0,
16,32,80,131,240,255,52,3,0,184,229,64,102,5,244,32,
12,149,245,1,0,133,0,138,232,1,157,9,192,210,121,80,
145,8,207,8,5,1,121,40,0,206,240,255,68,3,14,117,
121,72,145,8,38,32,12,149,232,1,121,40,101,12,103,12,
79,5,13,221,145,133,0,133,160,130,123,64,76,12,1,130,
240,255,84,3,247,26,3,1,181,12,13,0,123,32,0,166,
255,64,229,16,229,16,38,56,12,221,210,1,60,5,0,133,
19,40,0,213,105,12,245,255,100,3,14,175,18,48,2,9,
9,0,0,246,3,6,202,6,200,5,120,2,171,6,120,2,
76,0,240,255,111,3,91,49,174,202,51,49,0,0,183,184,
0,0,192,153,224,209,34,208,133,78,5,81,244,29,243,29,
192,164,0,0,44,12,143,78,240,255,127,3,115,124,166,144,
196,149,180,72,242,153,184,56,52,16,173,200,180,176,0,0,
45,145,179,72,208,37,73,66,161,72,212,165,83,132,240,255,
143,3,138,152,238,204,196,201,50,206,231,177,16,151,46,205,
243,141,142,134,46,208,0,0,20,0,0,0,43,4,0,0,
0,0,0,0,240,255,159,3,39,20,0,0,16,0,14,0,
15,0,64,84,163,4,165,4,12,0,16,128,113,4,73,4,
78,214,154,2,20,0,1,0,194,40,240,255,175,3,213,169,
80,170,228,72,0,3,242,209,128,86,128,58,4,0,77,12,
20,1,121,80,5,130,14,1,229,48,144,210,0,211,0,66,
240,255,191,3,9,250,0,211,0,74,80,211,122,80,34,48,
103,12,122,32,229,64,3,1,0,178,103,12,121,48,159,8,
2,1,32,1,242,40,240,255,207,3,203,212,13,181,105,1,
243,40,13,181,102,1,247,40,13,181,211,5,246,40,13,181,
208,5,26,205,7,1,235,40,26,205,202,5,240,255,223,3,
236,170,252,40,13,181,195,5,233,40,13,181,193,5,38,40,
13,181,3,9,181,12,1,0,49,48,103,12,52,1,121,80,
145,8,240,255,239,3,177,244,159,8,2,1,12,1,207,8,
1,213,2,1,228,24,121,40,192,170,0,206,101,12,103,12,
187,1,48,3,174,13,111,56,240,255,255,3,145,237,5,43,
93,181,78,1,6,43,93,181,99,1,21,32,18,40,105,12,
97,1,22,40,12,181,0,211,247,32,0,150,0,142,240,255,
15,4,133,198,12,181,234,1,229,40,144,170,121,72,51,48,
103,12,76,12,229,5,121,16,121,76,38,40,12,181,224,5,
121,40,80,171,240,255,31,4,17,187,229,72,253,48,82,32,
5,197,3,1,181,12,10,0,0,42,13,140,3,1,181,12,
11,0,254,40,4,170,81,12,194,48,240,255,47,4,167,111,
62,32,229,40,144,171,96,12,194,56,0,133,218,64,217,64,
1,5,48,7,57,48,215,40,35,32,26,165,4,1,48,32,
240,255,63,4,140,33,26,164,4,1,253,20,184,1,230,1,
253,16,80,173,253,76,0,211,178,1,59,48,253,28,175,1,
253,24,0,211,172,1,240,255,79,4,201,238,72,12,27,40,
0,182,215,40,29,56,12,188,165,1,103,12,145,8,242,40,
12,181,162,5,72,12,192,194,80,134,0,182,240,255,95,4,
37,252,206,56,255,67,103,12,145,8,246,40,12,181,151,5,
80,4,50,48,146,1,56,33,25,40,0,213,105,12,69,1,
27,40,240,255,111,4,79,229,0,182,138,1,49,33,27,197,
17,1,12,149,3,1,181,12,1,0,0,50,172,32,4,197,
245,1,253,44,12,140,248,1,240,255,127,4,206,126,253,32,
82,40,12,141,58,48,237,1,0,202,53,48,237,32,215,56,
12,140,6,1,56,32,13,157,15,1,0,211,226,1,240,255,
143,4,9,181,0,211,0,211,12,141,11,1,54,32,13,157,
6,1,0,211,56,32,12,157,215,1,0,211,229,24,212,1,
56,48,12,164,240,255,159,4,226,158,0,211,208,1,30,0,
186,0,60,48,204,1,52,48,216,80,103,12,145,8,38,40,
13,181,186,1,233,40,12,181,249,1,240,255,175,4,50,6,
0,213,216,80,191,1,80,172,216,72,228,24,228,24,145,8,
12,181,216,16,251,1,192,202,1,5,249,3,121,88,5,170,
240,255,191,4,90,49,99,4,229,32,0,129,144,128,122,64,
193,32,206,48,203,56,0,90,1,58,26,196,26,236,10,1,
0,211,0,211,12,237,240,255,207,4,237,252,249,1,121,32,
5,130,18,1,0,173,7,1,121,32,4,130,3,1,181,12,
13,0,80,172,122,56,61,32,0,157,123,88,240,255,223,4,
18,111,5,170,6,1,0,133,0,58,8,1,123,64,80,139,
80,252,0,246,0,34,2,58,0,229,121,72,125,80,126,88,
123,48,240,255,239,4,209,224,0,149,124,80,204,40,0,182,
205,32,26,196,3,1,181,12,14,0,204,80,203,32,124,48,
0,198,203,64,125,36,0,150,240,255,255,4,53,182,96,12,
124,32,75,130,7,1,204,48,0,173,0,74,0,211,4,131,
253,1,205,48,125,56,124,40,0,211,0,211,27,221,240,255,
15,5,120,189,7,1,0,34,5,130,250,1,0,166,0,66,
247,1,121,48,206,40,0,206,206,72,205,32,125,40,0,150,
205,80,96,12,240,255,31,5,2,232,121,32,75,129,5,1,
205,48,0,173,0,74,255,74,5,130,8,1,75,130,10,1,
125,48,126,32,0,66,254,32,255,66,240,255,47,5,240,8,
62,32,122,40,126,48,96,12,126,32,80,172,80,165,124,40,
80,170,195,56,0,51,26,196,10,1,12,197,5,1,121,48,
240,255,63,5,172,118,75,210,3,1,0,51,1,182,0,213,
0,83,0,251,196,48,26,245,241,1,197,48,227,56,80,133,
123,64,122,88,26,245,240,255,79,5,113,218,31,1,0,42,
125,32,26,140,24,1,12,141,19,1,121,32,74,130,19,1,
0,234,126,80,123,56,0,194,0,230,148,250,240,255,95,5,
168,28,0,252,0,230,0,246,96,12,126,48,122,56,123,32,
0,157,230,1,121,32,0,142,0,74,123,32,0,150,225,1,
123,32,240,255,111,5,72,182,148,130,7,1,227,88,198,48,
0,211,226,56,20,32,214,1,226,88,223,32,125,40,26,164,
99,4,12,141,9,1,121,48,240,255,127,5,232,67,74,210,
99,4,223,16,223,16,2,13,99,4,228,6,121,40,0,142,
221,32,223,72,124,40,0,142,4,130,221,72,99,4,240,255,
143,5,79,198,13,149,0,3,120,88,27,149,13,1,0,186,
0,149,0,182,0,43,0,74,13,157,120,4,0,249,0,248,
0,209,0,208,247,255,159,5,243,103,248,1,0,154,0,35,
0,66,13,189,120,4,0,251,0,211,250,1,240,255,168,5,
212,239,120,88,121,80,210,12,121,48,111,56,0,246,0,34,
82,130,1,173,41,42,80,170,121,72,19,49,80,130,67,210,
254,1,240,255,184,5,56,129,122,64,103,12,122,32,4,130,
248,1,121,32,149,146,6,1,245,40,27,205,238,1,0,182,
103,12,210,12,120,4,6,8,240,255,200,5,224,144,193,48,
18,32,218,64,127,96,254,40,4,170,100,12,225,80,216,80,
0,133,217,64,123,64,126,64,110,12,217,32,4,130,240,255,
216,5,189,60,99,4,194,48,65,32,0,66,80,195,229,64,
225,32,206,40,26,141,99,4,225,36,80,130,224,64,225,24,
225,44,225,24,240,255,232,5,68,28,0,133,75,12,142,8,
124,80,30,40,123,56,4,204,5,1,4,250,0,188,123,88,
3,1,149,170,123,16,85,250,6,1,240,255,248,5,31,37,
125,88,210,12,125,24,254,1,124,48,35,40,12,183,63,1,
144,170,0,181,166,9,124,48,30,40,13,204,91,1,13,181,
240,255,8,6,208,27,108,1,13,180,37,1,29,40,0,132,
13,204,126,64,142,8,28,32,27,149,63,5,31,40,26,205,
120,1,34,32,27,149,240,255,24,6,110,181,56,5,13,149,
123,1,48,32,27,149,54,1,0,139,13,180,103,1,51,40,
26,205,47,5,0,50,121,80,103,12,121,40,240,255,40,6,
180,96,192,178,66,170,103,12,215,32,233,56,4,157,225,1,
121,88,142,8,35,40,26,204,3,1,103,12,251,1,121,40,
4,170,240,255,56,6,16,239,79,1,233,48,103,12,212,1,
224,16,0,173,22,56,144,170,5,183,1,242,0,243,103,13,
224,48,144,210,121,80,121,44,240,255,72,6,242,65,6,33,
0,143,0,133,121,16,74,12,58,1,255,63,213,5,166,6,
159,6,162,6,126,16,12,1,126,80,192,210,80,214,240,255,
88,6,77,49,206,56,255,83,242,48,103,12,126,48,103,12,
246,48,219,1,1,253,142,8,121,88,94,12,63,56,74,130,
0,231,160,130,240,255,104,6,12,122,160,130,192,146,122,64,
103,12,122,48,35,40,12,183,103,12,121,40,4,170,21,1,
156,1,142,8,5,210,17,1,121,80,240,255,120,6,200,223,
224,48,144,210,122,80,122,36,122,16,122,44,122,16,74,12,
229,24,121,24,2,1,4,1,244,48,103,12,245,1,0,213,
240,255,136,6,156,217,103,12,194,48,80,194,108,12,195,5,
124,80,19,48,27,13,229,24,124,48,35,40,0,182,166,1,
224,56,144,251,0,35,240,255,152,6,137,73,0,251,0,43,
80,251,224,88,75,12,229,24,213,1,0,202,0,133,251,1,
13,181,153,1,252,40,2,1,27,40,0,181,240,255,168,6,
10,134,2,13,202,1,168,5,192,48,203,80,204,80,193,40,
223,72,206,72,7,9,221,64,193,40,80,132,0,142,205,72,
99,4,240,255,184,6,171,47,193,32,225,64,197,32,227,64,
198,32,226,64,0,133,0,66,0,211,26,205,253,1,195,48,
199,40,0,66,0,211,26,205,240,255,200,6,215,225,253,1,
0,3,203,48,204,80,205,40,235,9,217,64,205,40,206,48,
63,32,26,205,11,1,255,58,75,250,3,1,0,159,240,255,
216,6,231,90,255,90,0,253,0,90,80,252,0,246,245,1,
66,32,108,12,193,40,223,72,2,9,51,1,0,173,221,72,
206,40,223,48,240,255,232,6,126,7,26,205,0,3,0,50,
223,24,223,24,0,203,221,72,0,42,62,32,0,167,192,141,
30,48,12,181,239,1,222,64,0,3,240,255,248,6,105,57,
221,40,5,170,234,9,221,40,4,170,3,1,181,12,15,0,
87,12,115,88,202,56,26,220,211,0,221,44,0,74,221,16,
240,255,8,7,71,226,221,44,1,74,221,16,0,133,222,24,
2,1,221,64,115,40,172,56,13,189,230,1,49,56,12,189,
211,0,127,96,168,56,240,255,24,7,82,255,0,173,168,72,
218,32,5,250,7,1,17,40,2,9,16,0,4,141,181,4,
183,4,99,56,5,130,110,4,225,56,206,40,240,255,40,7,
33,223,26,237,45,5,0,59,225,24,225,24,217,32,4,130,
104,4,196,40,219,72,218,32,17,40,13,141,4,1,4,130,
218,72,240,255,56,7,79,254,127,96,0,133,230,64,216,72,
0,43,82,170,37,1,80,250,224,88,142,8,218,32,4,130,
9,1,31,32,13,148,4,1,240,255,72,7,171,212,30,32,
27,197,3,1,181,12,12,0,2,9,35,0,0,246,183,6,
157,7,120,2,120,2,223,7,132,7,218,7,122,7,245,255,
88,7,166,168,132,8,240,8,22,7,22,7,240,7,120,2,
207,7,224,6,93,8,1,8,248,6,240,255,99,7,86,59,
83,162,16,1,218,56,4,250,3,1,181,12,12,0,227,56,
198,48,27,221,3,1,181,12,18,0,225,40,0,75,227,16,
240,255,115,7,95,66,144,138,144,170,100,12,225,80,17,40,
218,72,157,1,227,48,197,32,27,197,3,1,181,12,19,0,
227,24,255,42,225,72,240,255,131,7,14,182,147,1,142,8,
195,40,0,182,115,80,224,16,142,8,55,56,12,221,211,0,
224,40,115,48,191,74,93,4,116,0,193,48,240,255,147,7,
49,206,255,34,13,141,0,3,80,132,0,150,206,32,26,149,
249,1,181,12,13,0,87,12,5,210,211,0,116,64,117,72,
53,48,240,255,163,7,24,120,115,80,26,244,12,1,56,48,
27,245,9,1,115,88,87,12,5,210,211,0,118,88,227,49,
176,12,118,56,51,48,12,221,240,255,179,7,228,20,211,0,
115,48,4,130,11,1,55,56,12,221,13,220,3,1,12,244,
93,4,224,48,144,211,0,42,181,1,54,56,13,220,240,255,
195,7,46,241,250,1,138,170,5,1,12,245,13,244,245,1,
93,4,56,56,12,245,13,220,240,1,93,4,10,13,73,12,
142,8,172,56,240,255,211,7,244,142,13,221,251,1,49,56,
13,221,93,4,211,0,121,9,110,12,1,5,214,1,212,211,
208,207,110,12,194,48,65,40,0,74,240,255,227,7,167,194,
250,41,1,74,249,41,2,74,17,40,80,206,229,72,97,12,
194,48,80,194,108,12,110,12,99,4,87,12,55,40,12,189,
240,255,243,7,113,190,211,0,115,80,202,56,26,220,211,0,
87,12,4,210,49,48,12,221,211,0,115,48,0,66,1,74,
93,4,0,213,115,80,240,255,3,8,123,239,110,12,194,48,
0,214,229,80,87,12,4,210,15,1,52,48,13,221,60,1,
50,48,13,220,64,1,115,32,115,88,49,48,240,255,19,8,
42,180,12,221,10,1,4,130,93,4,12,1,115,88,74,12,
115,56,52,48,13,244,211,0,172,48,13,221,21,1,49,48,
13,221,240,255,35,8,75,131,208,12,209,12,194,48,80,194,
108,12,99,56,218,32,5,130,110,4,115,56,49,48,13,245,
93,4,172,48,12,245,13,244,240,255,51,8,87,177,208,1,
211,0,220,48,229,40,0,206,194,48,80,210,0,205,213,48,
4,205,4,1,13,157,253,1,228,1,75,170,250,1,240,255,
67,8,113,26,116,72,210,12,116,16,254,1,221,1,142,8,
5,210,3,1,103,12,252,1,115,80,185,1,87,12,5,210,
211,0,115,88,240,255,83,8,187,198,89,12,214,48,18,205,
255,1,0,182,220,40,0,205,75,170,191,1,231,1,87,12,
115,80,116,88,202,56,26,220,211,0,240,255,99,8,75,139,
110,12,3,9,191,220,0,160,96,226,108,12,107,12,102,12,
217,56,4,250,104,4,0,253,216,88,78,12,4,1,38,56,
240,255,115,8,103,104,13,221,4,1,2,33,242,1,202,16,
115,56,0,67,1,75,116,48,172,56,216,88,13,221,222,1,
49,56,12,221,211,0,240,255,131,8,40,130,93,4,142,8,
226,32,198,56,27,228,18,1,0,43,13,205,4,1,20,40,
0,190,249,1,115,80,0,242,20,32,0,230,240,255,147,8,
127,32,226,40,96,12,20,32,226,56,0,157,226,88,115,48,
226,56,199,40,26,236,3,1,181,12,20,0,0,83,225,40,
1,75,240,255,163,8,232,221,224,24,87,12,115,80,55,32,
202,40,27,204,12,229,211,0,87,12,4,210,50,48,12,221,
211,0,115,48,0,66,1,74,240,255,179,8,113,205,87,12,
5,210,211,0,226,48,2,66,3,74,51,48,13,244,5,1,
144,133,35,40,80,171,2,1,87,12,4,210,49,48,240,255,
195,8,101,57,12,221,211,0,226,48,4,66,5,74,115,56,
0,35,1,43,0,211,0,211,176,12,226,56,5,51,138,210,
7,1,130,170,240,255,211,8,123,83,8,1,20,48,0,222,
226,88,93,4,4,130,130,170,250,1,225,48,206,40,27,205,
3,1,181,12,21,0,0,42,80,170,240,255,227,8,67,14,
224,72,80,252,0,246,225,80,142,8,30,40,12,204,241,1,
142,8,226,44,12,181,237,1,93,4,142,8,226,56,250,43,
240,255,243,8,184,235,13,205,10,1,20,40,0,189,198,40,
27,237,3,1,181,12,22,0,226,88,245,1,94,12,115,80,
0,34,1,42,226,48,240,255,3,9,2,100,80,252,0,246,
177,12,115,48,0,66,1,74,226,48,18,56,0,245,176,12,
226,56,255,51,131,210,8,1,4,130,130,170,246,255,19,9,
231,141,7,1,20,40,0,189,226,88,93,4,130,170,251,1,
251,43,225,72,93,4,240,255,29,9,222,58,34,40,96,207,
206,48,0,181,0,34,0,202,1,50,74,130,0,211,0,3,
119,88,205,56,80,212,0,222,204,48,26,244,240,255,45,9,
26,106,7,1,0,186,1,83,0,219,0,251,204,88,119,4,
181,12,23,0,255,131,255,3,115,64,116,72,117,88,62,56,
26,157,240,255,61,9,103,150,27,189,12,1,5,170,12,1,
0,155,146,170,0,230,80,250,4,170,252,1,240,57,26,157,
3,1,183,12,24,0,118,64,240,255,77,9,67,106,208,9,
5,210,18,1,74,130,3,1,183,12,25,0,227,57,0,231,
118,56,26,229,3,1,183,12,28,0,115,40,192,170,240,255,
93,9,56,155,116,56,0,238,255,74,117,4,198,9,0,211,
119,72,210,41,13,143,3,1,183,12,26,0,118,40,96,170,
0,238,205,56,240,255,109,9,149,55,27,189,198,1,204,72,
115,40,138,130,237,1,118,56,64,230,160,130,119,68,228,1,
1,173,0,172,139,72,114,88,200,40,240,255,125,9,136,85,
140,72,201,40,141,72,48,48,140,84,140,16,140,32,201,40,
27,140,93,1,142,8,140,84,48,32,27,196,35,1,140,56,
240,255,141,9,26,31,255,43,26,164,211,0,62,32,26,141,
211,0,35,32,27,196,237,1,27,32,27,197,10,1,0,202,
0,133,90,12,141,48,240,255,157,9,10,131,0,66,1,74,
141,16,141,16,224,1,34,32,5,197,4,1,140,16,61,48,
218,1,224,40,144,179,0,203,80,171,224,72,240,255,173,9,
25,227,212,1,140,56,255,43,57,32,12,149,14,1,62,56,
27,164,27,189,6,1,59,32,12,141,13,140,211,0,199,1,
48,32,240,255,189,9,34,219,12,141,211,0,195,1,35,32,
26,164,4,1,48,32,26,164,36,1,62,32,27,165,49,1,
57,32,12,141,13,140,4,1,240,255,205,9,92,118,48,32,
12,141,211,0,173,32,12,149,5,1,112,32,140,68,140,16,
171,1,13,148,175,1,140,48,200,40,4,180,211,0,240,255,
221,9,115,225,140,60,172,32,27,229,211,0,114,4,39,9,
181,12,29,0,0,133,0,173,224,24,114,4,57,32,13,148,
151,1,0,178,240,255,237,9,211,141,139,32,5,130,5,1,
200,32,0,131,13,156,242,1,94,12,5,210,236,13,140,56,
255,83,140,56,0,35,254,43,144,130,240,255,253,9,37,62,
144,170,27,141,46,1,33,32,27,141,211,0,255,51,0,34,
1,42,253,51,254,59,184,15,140,56,254,67,202,32,255,51,
240,255,13,10,84,195,26,196,26,220,8,1,253,51,26,196,
26,220,8,1,141,24,141,24,5,1,253,51,26,196,26,220,
13,1,141,48,80,132,240,255,29,10,160,136,0,150,254,35,
0,66,1,74,253,83,0,51,254,83,140,24,140,24,211,1,
141,48,27,196,186,1,141,16,141,16,242,1,240,255,45,10,
140,116,0,43,173,32,26,141,187,1,59,32,12,141,9,1,
254,43,57,32,12,141,15,1,255,43,254,75,140,24,157,1,
13,140,240,255,61,10,33,16,20,1,58,32,12,141,6,1,
254,43,13,164,168,1,183,12,4,0,219,32,196,40,27,141,
42,1,255,51,0,34,1,42,240,255,77,10,189,92,0,59,
139,16,114,4,211,0,254,43,58,32,13,141,4,1,0,133,
0,67,8,1,255,51,0,34,1,42,89,12,140,24,240,255,
93,10,214,9,140,24,140,76,140,24,140,52,0,34,1,42,
89,12,140,76,140,24,140,24,140,52,139,40,5,170,5,1,
140,56,2,35,240,255,109,10,68,178,3,43,114,4,94,12,
74,130,38,1,30,1,0,43,49,32,12,141,24,1,219,48,
17,32,0,149,219,80,2,42,224,72,240,255,125,10,21,89,
0,149,206,84,140,24,140,56,0,51,202,32,26,196,26,220,
3,1,253,83,157,1,254,43,0,75,0,42,254,75,1,42,
240,255,141,10,155,7,154,1,181,12,30,0,22,32,140,56,
3,43,0,51,4,170,0,138,73,12,62,40,140,84,255,50,
192,194,0,167,0,207,240,255,157,10,160,217,140,56,2,51,
27,197,4,1,3,35,26,141,3,1,181,12,31,0,0,171,
146,170,0,198,80,210,4,170,252,1,80,146,252,255,173,10,
213,5,0,43,0,182,1,5,129,9,240,255,177,10,134,144,
138,88,88,12,5,130,74,170,2,1,138,4,183,12,31,0,
13,65,13,73,13,89,0,34,1,42,5,130,0,3,25,13,
240,255,193,10,94,19,4,49,179,12,23,13,4,5,198,10,
0,0,0,0,0,0,104,0,138,88,31,56,26,221,22,1,
251,57,26,221,3,1,240,255,209,10,22,36,183,12,39,0,
12,9,3,11,6,11,9,11,16,11,6,14,36,14,88,14,
241,14,36,15,187,14,41,15,0,246,162,50,240,255,225,10,
74,177,138,56,0,2,140,56,253,35,195,48,0,150,191,34,
4,130,3,1,183,12,32,0,219,48,197,40,26,204,3,1,
181,12,240,255,241,10,247,95,33,0,224,40,2,74,224,64,
0,35,254,67,140,24,255,59,0,35,0,66,1,35,1,66,
206,84,17,32,0,150,219,80,240,255,1,11,127,102,1,5,
128,9,88,12,90,12,138,4,80,212,0,207,0,3,5,130,
0,3,144,133,35,48,128,170,64,203,0,3,11,9,240,255,
17,11,250,208,188,64,9,9,189,64,0,133,191,64,35,32,
190,64,90,9,63,9,138,4,15,33,15,49,80,138,80,170,
4,211,254,1,240,255,33,11,193,91,0,142,80,170,80,170,
0,166,4,41,0,166,3,65,0,3,25,54,0,0,248,255,
129,88,20,9,84,12,12,1,129,88,240,255,49,11,116,200,
16,9,85,12,8,1,129,88,12,9,9,13,4,1,129,88,
8,9,6,13,55,9,37,9,27,9,129,4,8,12,213,11,
240,255,65,11,145,60,188,64,130,88,0,162,19,57,0,231,
189,64,0,34,184,64,1,34,0,146,0,231,185,64,0,248,
144,239,190,72,112,173,240,255,81,11,52,223,191,72,144,247,
186,80,112,213,187,80,130,4,0,254,255,33,189,40,144,143,
190,32,80,142,191,32,0,142,188,32,0,3,240,255,97,11,
175,128,190,32,62,40,26,141,0,3,67,130,5,1,0,133,
0,173,0,213,3,1,168,16,1,212,191,64,190,72,188,80,
189,80,240,255,113,11,9,42,0,3,188,32,189,40,5,130,
4,170,4,1,190,64,191,64,0,3,74,130,6,1,80,170,
64,130,190,24,251,1,250,1,240,255,129,11,151,94,188,64,
189,72,0,3,184,48,188,40,188,80,184,72,185,48,189,40,
189,80,185,72,186,48,190,40,186,72,190,80,187,48,243,255,
145,11,87,97,191,40,187,72,191,80,0,3,0,42,184,72,
1,42,185,72,2,42,186,72,3,42,187,72,0,3,240,255,
158,11,116,15,17,89,41,48,190,80,0,213,191,80,75,130,
5,1,191,16,4,169,1,128,0,129,188,64,189,72,86,12,
98,12,2,5,240,255,174,11,244,197,0,0,0,0,255,89,
109,12,0,133,0,138,190,48,35,56,18,245,5,210,12,1,
245,81,188,48,189,56,80,250,64,210,240,255,190,11,76,124,
64,170,64,130,74,130,12,1,236,25,249,1,191,24,234,5,
5,250,4,210,9,1,4,169,1,128,0,129,227,5,168,16,
240,255,206,11,150,238,0,172,144,132,244,1,18,171,0,131,
246,1,24,0,130,88,186,32,190,40,13,141,15,1,19,165,
1,129,91,12,131,64,240,255,222,11,116,229,246,41,27,140,
130,4,184,32,185,40,144,130,128,170,131,24,253,1,3,1,
184,32,185,40,187,48,191,56,128,222,188,48,240,255,238,11,
64,33,189,56,3,130,16,1,19,189,33,148,32,149,3,130,
8,1,4,249,1,208,0,209,186,32,190,64,187,32,191,64,
188,80,240,255,254,11,87,202,189,88,130,4,18,190,16,211,
3,150,250,1,190,16,160,210,128,250,246,1,191,32,128,130,
64,133,191,64,201,1,130,88,240,255,14,12,249,101,190,32,
35,40,30,9,189,48,185,40,17,9,184,40,16,9,189,64,
0,162,188,48,185,40,11,9,184,40,9,9,189,48,240,255,
30,12,126,93,18,206,0,131,188,64,189,72,130,4,240,255,
48,133,131,88,253,57,131,170,129,130,144,198,4,251,252,1,
176,170,131,4,240,255,46,12,14,202,0,165,186,40,0,166,
190,64,187,32,191,40,128,166,112,133,191,64,0,3,32,0,
130,88,190,40,35,32,242,9,190,16,240,255,62,12,200,197,
184,32,185,40,144,130,128,170,246,57,131,88,188,48,21,210,
26,1,80,170,64,130,188,48,189,56,11,197,4,1,13,197,
240,255,78,12,168,231,10,237,12,1,184,48,185,56,64,250,
64,210,184,80,185,88,131,24,240,1,188,80,189,88,130,4,
19,237,17,196,16,197,240,255,94,12,174,209,32,130,241,1,
144,212,190,80,188,80,130,4,0,0,255,89,188,32,189,40,
80,170,64,130,80,170,64,130,189,56,18,238,240,255,110,12,
215,237,0,131,188,56,0,230,80,170,64,130,48,17,1,1,
239,5,16,39,0,242,0,172,0,132,62,9,5,210,4,250,
8,1,240,255,126,12,135,248,88,12,247,49,5,130,26,205,
3,1,4,170,23,1,181,12,5,0,0,242,0,172,46,9,
5,210,4,250,15,1,127,64,240,255,142,12,31,255,128,72,
88,12,27,48,5,130,27,181,2,1,7,1,127,32,128,40,
4,1,0,242,0,173,29,9,11,57,4,250,24,17,240,255,
158,12,173,4,6,49,6,57,0,249,20,5,0,0,0,0,
0,0,0,0,0,0,168,12,0,160,0,0,132,0,0,0,
173,12,204,204,250,255,174,12,14,23,205,204,125,0,0,0,
0,0,0,15,0,0,240,255,183,12,101,115,44,32,249,65,
253,73,251,81,249,89,0,133,127,64,128,64,231,65,188,64,
189,64,241,65,243,17,2,1,8,1,145,8,240,255,199,12,
229,119,244,40,13,204,4,1,12,180,3,1,231,17,145,8,
207,8,13,1,214,17,0,181,188,32,223,41,4,143,248,1,
143,9,240,255,215,12,154,124,18,206,0,131,188,64,189,72,
242,1,232,40,4,205,7,1,127,40,4,170,4,1,193,73,
127,16,233,1,191,81,192,33,240,255,231,12,209,62,5,130,
182,1,128,32,4,130,19,1,199,33,191,64,127,32,5,130,
3,1,178,33,0,129,175,65,177,65,41,32,190,64,240,255,
247,12,177,68,186,41,4,181,12,1,91,12,128,16,0,133,
195,1,189,40,163,33,179,25,1,166,0,165,159,65,91,12,
86,12,156,33,240,255,7,13,131,4,165,49,74,130,1,129,
157,49,5,130,7,1,149,65,95,12,85,12,86,12,145,25,
253,1,79,12,98,12,128,48,143,57,255,255,23,13,77,237,
157,5,240,255,24,13,47,70,1,213,80,213,72,89,127,80,
0,253,70,89,4,130,13,1,4,170,5,1,210,12,43,48,
103,12,116,1,188,64,189,72,240,255,40,13,230,66,191,88,
41,48,190,80,2,1,109,12,127,56,191,40,41,48,4,170,
248,48,5,250,103,12,86,12,14,49,95,12,91,12,240,255,
56,13,30,64,186,48,33,56,26,221,9,1,35,56,26,221,
10,1,36,17,1,1,84,12,242,1,168,12,31,25,1,1,
85,12,237,1,240,255,72,13,213,40,184,32,185,40,90,57,
13,221,6,1,144,130,128,170,186,16,186,48,250,1,184,64,
185,72,91,12,0,253,127,88,76,13,240,255,88,13,131,147,
189,72,71,49,127,56,5,151,4,250,7,1,188,64,4,25,
247,1,246,1,0,0,0,0,0,197,188,64,57,33,0,150,
240,255,104,13,27,97,58,57,51,41,49,33,80,210,64,170,
64,130,4,251,252,1,43,65,43,73,127,16,127,48,20,56,
26,220,225,1,188,48,240,255,120,13,80,31,38,57,13,223,
3,1,5,171,0,131,127,48,21,56,27,221,8,1,127,16,
32,49,80,170,64,130,52,211,253,1,246,1,240,255,136,13,
33,62,3,130,4,1,217,17,1,1,21,33,14,65,14,73,
22,57,0,239,0,231,16,57,160,130,130,170,17,1,0,251,
252,1,240,255,152,13,6,211,58,9,210,12,200,5,0,0,
0,0,0,0,0,8,0,96,0,240,0,16,252,255,101,12,
132,0,153,153,144,250,144,250,240,255,168,13,241,235,0,225,
186,49,21,56,19,40,74,245,74,206,4,1,74,210,27,197,
231,1,80,213,176,25,1,1,29,9,44,48,103,12,240,255,
184,13,141,189,249,48,170,41,75,170,4,1,0,169,166,73,
248,48,103,12,163,41,22,48,0,133,27,205,4,1,0,205,
0,131,252,1,240,255,200,13,169,182,43,48,0,206,127,72,
0,150,4,130,103,12,127,48,103,12,201,1,0,0,255,89,
20,56,201,89,0,253,127,88,128,80,240,255,216,13,237,132,
74,209,10,1,232,48,103,12,128,48,5,210,5,1,0,211,
128,80,43,48,249,1,0,213,183,33,183,41,188,57,80,170,
240,255,232,13,135,153,64,130,64,210,4,251,252,1,175,65,
175,73,20,56,27,220,0,245,127,16,0,253,4,210,127,88,
43,56,0,246,103,12,243,255,248,13,217,164,128,24,5,1,
80,213,127,80,232,48,103,12,159,25,228,1,229,48,127,56,
0,245,229,80,205,5,240,255,5,14,143,27,0,0,5,130,
0,3,253,89,146,186,168,16,80,234,17,65,17,73,22,9,
80,252,0,238,71,9,13,65,13,73,7,49,248,255,21,14,
19,155,178,12,6,49,177,12,80,252,0,238,235,5,29,14,
31,14,240,255,33,14,187,202,34,14,114,177,0,23,138,88,
139,170,5,130,22,1,109,12,190,32,35,40,0,165,190,72,
136,64,98,12,19,49,103,9,240,255,49,14,107,19,134,64,
135,72,136,40,74,170,1,132,0,133,90,12,233,49,179,12,
106,48,177,12,138,4,1,172,80,172,0,132,168,16,240,255,
65,14,48,248,138,4,67,14,229,145,3,51,79,195,6,247,
211,224,9,27,205,145,10,121,252,236,9,133,151,135,8,155,
57,179,5,25,240,255,81,14,81,62,0,0,114,177,15,19,
15,176,14,53,170,184,2,59,138,88,134,64,135,72,106,48,
246,33,246,41,176,12,131,170,4,1,240,255,97,14,53,114,
0,133,0,173,138,4,106,48,239,33,239,41,176,12,131,170,
213,1,236,33,236,41,106,48,179,12,26,9,136,80,9,49,
240,255,113,14,211,247,38,9,109,12,190,32,136,40,0,166,
190,64,98,12,138,4,122,14,25,246,238,6,72,147,244,6,
170,228,248,34,234,245,240,255,129,14,56,65,252,210,114,177,
0,123,255,255,0,255,0,0,0,0,255,89,134,64,135,72,
88,12,137,72,90,12,106,48,176,12,137,48,254,255,145,14,
123,235,246,5,0,0,240,255,149,14,146,188,147,14,0,0,
255,89,251,65,251,73,0,34,1,42,246,81,245,17,244,17,
243,53,5,210,245,5,243,49,179,12,238,49,251,255,165,14,
14,212,177,12,247,1,0,0,0,0,170,14,240,255,172,14,
243,229,0,0,250,89,254,81,250,49,250,65,250,73,179,12,
249,49,227,9,242,5,242,89,246,9,241,49,179,12,238,5,
144,170,240,255,188,14,80,47,112,213,136,80,80,170,38,49,
134,64,135,72,176,12,128,170,134,32,135,40,112,213,137,80,
131,210,3,1,27,49,178,12,240,255,204,14,252,139,9,49,
233,9,137,24,3,1,24,49,176,12,136,48,0,206,138,4,
214,14,213,128,244,98,154,151,249,240,196,171,250,168,240,255,
220,14,29,253,27,138,253,218,150,203,252,26,161,170,255,186,
255,255,0,245,0,0,230,14,0,128,2,1,233,14,15,201,
2,215,236,14,240,255,236,14,11,51,249,162,2,131,239,14,
249,162,0,131,138,88,144,170,112,213,136,80,80,170,248,49,
179,12,144,9,17,56,0,223,136,48,240,255,252,14,96,64,
148,250,0,211,136,80,15,49,2,130,3,1,180,9,5,1,
228,49,179,12,18,49,166,9,136,48,128,210,112,213,4,130,
240,255,12,15,138,221,0,206,138,4,15,15,243,142,243,10,
202,162,250,108,91,165,1,21,15,201,2,207,0,0,25,15,
58,194,226,174,149,181,240,255,28,15,133,45,239,76,167,170,
248,110,255,255,255,224,255,255,0,255,0,0,138,88,195,49,
177,12,203,1,0,0,255,89,14,65,14,73,246,255,44,15,
35,182,197,9,9,65,9,73,9,33,9,41,243,9,3,49,
178,12,244,5,54,15,240,255,58,15,30,42,0,133,230,64,
231,64,80,252,29,49,0,34,0,90,0,42,0,66,12,189,
5,1,23,41,0,182,75,210,247,1,20,57,240,255,74,15,
215,45,17,33,12,149,18,57,0,193,0,128,11,49,0,43,
5,170,13,1,0,165,0,66,0,251,0,209,0,208,248,1,
171,6,240,255,90,15,68,253,199,0,0,16,0,8,161,15,
170,15,1,35,121,64,30,9,58,2,1,133,0,132,24,40,
0,166,213,64,80,138,80,170,240,255,106,15,163,143,0,166,
214,64,121,16,11,1,17,9,250,1,8,1,43,33,192,64,
0,133,41,69,41,69,41,69,41,69,5,33,2,64,240,255,
122,15,96,184,4,33,3,64,221,5,191,101,0,133,0,51,
120,88,224,80,216,80,142,8,5,210,5,1,73,114,137,103,
255,1,250,1,240,255,138,15,253,197,136,103,255,1,120,56,
136,97,34,40,0,167,73,98,137,103,255,1,7,41,13,165,
1,3,5,41,12,141,231,1,2,3,249,255,154,15,181,210,
78,0,89,0,187,14,148,3,149,3,150,3,151,3,240,255,
253,0,101,164,10,13,10,13,86,79,82,69,82,87,84,73,
32,69,72,84,32,69,85,70,67,78,73,84,78,79,32,83,
73,83,44,78,240,255,13,1,130,216,79,67,44,83,84,65,
32,78,78,65,32,68,65,84,32,78,84,40,80,89,32,69,
32,89,82,79,78,32,63,41,0,32,240,255,29,1,7,92,
10,13,79,68,89,32,85,79,87,32,83,73,32,72,79,67,
77,77,39,65,32,83,79,84,66,32,32,69,52,49,83,32,
240,255,45,1,160,211,65,80,69,67,32,83,84,40,80,89,
32,69,41,89,32,44,82,79,49,32,32,53,84,40,80,89,
32,69,41,78,0,63,240,255,161,15,241,238,20,0,17,0,
3,0,6,0,26,0,38,0,1,0,0,0,255,255,128,0,
47,0,8,0,24,0,26,0,38,0,1,0,254,255,177,15,
81,240,0,0,0,0,1,0,58,15,197,240,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36};


// I2C suppport routines
bool wireFail=false;

void WireEnd() {
  if (!wireFail);
    Wire.end();
}

void WireBegin() {
  static bool configured = false;
  static byte rxbuffer[64];
  static byte txbuffer[64];
  if (!configured) {
    pinMode(A8, INPUT);
    pinMode(A9, INPUT);
    if (analogRead(A8)<1000) wireFail=true;
    if (analogRead(A8)<1000) wireFail=true;
    if (wireFail) return;
    pinMode(A8, OUTPUT);
    pinMode(A9, OUTPUT);
    Wire.setDelay_us(1);
    Wire.setRxBuffer(rxbuffer, 64);
    Wire.setTxBuffer(txbuffer, 64);
    configured = true;
  }
  Wire.begin();
}

void writeByte(byte chip, byte reg, byte data) {
  if (wireFail) return;
  Wire.beginTransmission(chip);
  Wire.write(reg);
  Wire.write(data);
  Wire.endTransmission();
}

byte readByte(byte chip, byte reg) {
  if (wireFail) return 0;
  Wire.beginTransmission(chip);
  Wire.write(reg);
  Wire.endTransmission();
  Wire.requestFrom(chip, (byte)1);
  Wire.available();
  return Wire.read();
}

// write Nova Data bus, should not be called when physically connected to Nova
int NovaModeD=0;
#ifdef TEENSY35
static unsigned char XBM[32];
int del=0;
#endif

void writeData(int A)
{ 
#ifdef TEENSY35
  for (int i=0; i<32; i++) XBM[i]=0;
  int d;
  d=0;
  if (A&0x8000) d += 0x60;
  if (A&0x4000) d += 0x06;
  XBM[8]=XBM[16]=d;
  d=0;
  if (A&0x2000) d += 0x06;
  if (A&0x1000) d += 0x60;
  XBM[9]=XBM[17]=d;
  d=0;
  if (A&0x800) d += 0x06;
  if (A&0x400) d += 0x60;
  XBM[10]=XBM[18]=d;
  d=0;
  if (A&0x200) d += 0x06;
  if (A&0x100) d += 0x60;
  XBM[11]=XBM[19]=d;
  d=0;
  if (A&0x80) d += 0x06;
  if (A&0x40) d += 0x60;
  XBM[12]=XBM[20]=d;
  d=0;
  if (A&0x20) d += 0x06;
  if (A&0x10) d += 0x60;
  XBM[13]=XBM[21]=d;
  d=0;
  if (A&0x8) d += 0x06;
  if (A&0x4) d += 0x60;
  XBM[14]=XBM[22]=d;
  d=0;
  if (A&0x2) d += 0x06;
  if (A&0x1) d += 0x60;
  XBM[15]=XBM[23]=d;
  //if ((millis()-del)>100)
  { del=millis();
    u8g2.drawXBM(64, 4, 64, 4, XBM);
    u8g2.sendBuffer();
  }
  return;
#endif
  WireBegin();
  static bool configured=false;
  if (NovaModeD!=2 || !configured) {
    writeByte(0x22, 0x01, 0x00);
    writeByte(0x23, 0x01, 0x00);
    NovaModeD=2; configured=true;
  }
  writeByte(0x22, 0x13, ~A);
  writeByte(0x23, 0x13, ~(A>>8));
  WireEnd();
}

// read Nova Data bus, should only be called when physically connected to Nova
unsigned short readData()
{ WireBegin();
  static bool configured=false;
  if (NovaModeD!=1 || !configured) {
    writeByte(0x22, 0x01, 0xff);
    writeByte(0x23, 0x01, 0xff);
    NovaModeD=1; configured=true;
  }
  unsigned short a=readByte(0x22, 0x13);
  unsigned short b=readByte(0x23, 0x13);
  return (a<<8)|b;
  WireEnd();
}

// write Nova Address bus, should not be called when physically connected to Nova
int NovaModeA=0;
void writeAddr(int A)
{ 
#ifdef TEENSY35
  for (int i=0; i<32; i++) XBM[i]=0;
  int d;
  d=0;
  if (A&0x8000) d += 0x60;
  if (A&0x4000) d += 0x06;
  XBM[8]=XBM[16]=d;
  d=0;
  if (A&0x2000) d += 0x06;
  if (A&0x1000) d += 0x60;
  XBM[9]=XBM[17]=d;
  d=0;
  if (A&0x800) d += 0x06;
  if (A&0x400) d += 0x60;
  XBM[10]=XBM[18]=d;
  d=0;
  if (A&0x200) d += 0x06;
  if (A&0x100) d += 0x60;
  XBM[11]=XBM[19]=d;
  d=0;
  if (A&0x80) d += 0x06;
  if (A&0x40) d += 0x60;
  XBM[12]=XBM[20]=d;
  d=0;
  if (A&0x20) d += 0x06;
  if (A&0x10) d += 0x60;
  XBM[13]=XBM[21]=d;
  d=0;
  if (A&0x8) d += 0x06;
  if (A&0x4) d += 0x60;
  XBM[14]=XBM[22]=d;
  d=0;
  if (A&0x2) d += 0x06;
  if (A&0x1) d += 0x60;
  XBM[15]=XBM[23]=d;
  //if ((millis()-del)>100)
  { del=millis();
    u8g2.drawXBM(64, 0, 64, 4, XBM);
    u8g2.sendBuffer();
  }
  return;
#endif
  WireBegin();
  static bool configured=false;
  if (NovaModeA!=2 || !configured) {
    writeByte(0x22, 0x00, 0x00);
    writeByte(0x23, 0x00, 0x00);
    NovaModeA=2; configured=true;
  }
  writeByte(0x22, 0x12, ~A);
  writeByte(0x23, 0x12, ~(A>>8));
  WireEnd();
}

// read Nova Address bus, should only be called when physically connected to Nova
unsigned short readAddr()
{ WireBegin();
  static bool configured=false;
  if (NovaModeA!=1 || !configured) {
    writeByte(0x22, 0x00, 0xff);
    writeByte(0x23, 0x00, 0xff);
    NovaModeA=1; configured=true;
  }
  unsigned short a=readByte(0x22, 0x12);
  unsigned short b=readByte(0x23, 0x12);
  WireEnd();
  return (a<<8)|b;
}

// write Nova status lights, should not be called when physically connected to Nova
int NovaModeL=0;
void writeLights(int A)
{ 
#ifdef TEENSY35
  return;
#endif
  WireBegin();
  static bool configured=false;
  if (NovaModeL!=2 || !configured) {
    writeByte(0x24, 0x01, 0x00);
    NovaModeL=2; configured=true;
  }
  writeByte(0x24, 0x13, ~A);
  WireEnd();
}

// read Nova status lights, should only be called when physically connected to Nova
byte readLights()
{ WireBegin();
  static bool configured=false;
  if (NovaModeL!=1 || !configured) {
    writeByte(0x24, 0x01, 0xff);
    NovaModeL=1; configured=true;
  }
  byte a = readByte(0x24, 0x13);
  WireEnd();
  return a;
}

// read switch bank
int readSwitches(void) {
  static bool configured = false;
  WireBegin();
  if(!configured) {
    writeByte(0x20, 0x0c, 0xff);
    writeByte(0x20, 0x0d, 0xff);
    writeByte(0x20, 0x00, 0xff);
    writeByte(0x20, 0x01, 0xff);
    configured = true;
  }
  short a = readByte(0x20, 0x12);
  short b = readByte(0x20, 0x13);
  WireEnd();
  return (~((a<<8)+b))&0xffff;
}

// enable ONE color led (1..10) from matrix next to control switches, 0 = disable, -1=restore output
void writeColor(int i) {
#ifdef TEENSY35
  if (i<0) return;
  i = ~i;
  for (byte a=18;  a<22; a++) pinMode(a, OUTPUT); 
  if (i&1) pinMode(18, INPUT); 
  if (i&2) pinMode(19, INPUT); 
  if (i&4) pinMode(20, INPUT); 
  if (i&8) pinMode(21, INPUT); 
  digitalWrite(18, i&1); // output 4bit data
  digitalWrite(19, (i>>1)&1);
  digitalWrite(20, (i>>2)&1);
  digitalWrite(21, (i>>3)&1);
  return;
#endif
  static bool configured = false;
  static int prevcolor=0;
  if (i<0) {
    writeByte(0x21, 0x13, prevcolor);
    return;
  }

  WireBegin();
  if (!configured) {
    writeByte(0x21, 0x01, 0x00);
    configured = true;
  }

  i %= 11;
  if (i==0)     ;
  else if (i>5) i = 64+(1<<((i-1)%5));
  else          i = 128+(1<<((i-1)%5));
  writeByte(0x21, 0x13, i);
  prevcolor=i;
  WireEnd();
}

// adapted from I2C eeprom library from https://playground.arduino.cc/code/I2CEEPROM
// added Wire.begin and Wire.end to allow sharing with u8g2
 
// WARNING: address is a page address, 6-bit end will wrap around
// also, data can be maximum of about 30 bytes, because the Wire library has a buffer of 32 bytes
void i2c_eeprom_write_page(int chip, unsigned int eeaddresspage, byte* data, byte length ) 
{ if (wireFail) return;
  writeColor(1);
  WireBegin();
  Wire.beginTransmission(chip);
  Wire.write((int)(eeaddresspage >> 8)); // MSB
  Wire.write((int)(eeaddresspage & 0xFF)); // LSB
  for (byte c = 0; c < length; c++)
    Wire.write(data[c]);
  Wire.endTransmission();
  delay(5);
  WireEnd();
  writeColor(0);
}

void i2c_eeprom_read_buffer(int chip, unsigned int eeaddress, byte *buffer, int length) 
{ if (wireFail) return;
  writeColor(2);
  WireBegin();
  Wire.beginTransmission(chip);
  Wire.write((int)(eeaddress >> 8)); // MSB
  Wire.write((int)(eeaddress & 0xFF)); // LSB
  Wire.endTransmission();
  Wire.requestFrom(chip,length);
  for (int c = 0; c < length; c++ )
    if (Wire.available()) buffer[c] = Wire.read();
  WireEnd();
  writeColor(0);
}

int counteRead=0;
byte i2c_eeprom_read_byte(int chip, unsigned int eeaddress) 
{ if (wireFail) return 0;
  byte rdata = 0xFF;
  if (++counteRead>10) writeColor(2);
  WireBegin();
  Wire.beginTransmission(chip);
  Wire.write((int)(eeaddress >> 8));   // MSB
  Wire.write((int)(eeaddress & 0xFF)); // LSB
  Wire.endTransmission();
  Wire.requestFrom(chip,1);
  if (Wire.available()) rdata = Wire.read();
  WireEnd();
  if (counteRead>10) 
  { writeColor(0);
    counteRead=0;
  }
  return rdata;
}

// 5 x 8 keycodes of keypad and switch bank of Nova version 3 frontpanel
// switch bank layout A  C  E  G  I   K  M  O  Q  S
//                    B  D  F  H  J   L  N  P  R  T

char keyCodes[] = {'T', 'R', 'P', 'N', 'L',   'S', 'Q', 'O', 'M', 'K', 
                   'J', 'H', 'F', 'D', 'B',   'I', 'G', 'E', 'C', 'A',
                    0,  '8', '5', '0', '2',    0,  '7', '4', '*', '1',
                    0,  '9', '6', '#', '3',    0,  'W', 'V', 'X', 'U'};
                 // 0=N/A                          7+9  4+6  *+#  1+3 (when pressing multiple keys at once)

// read keyboard and/or control switches matrix, note keyboard matrix drive multiplexed with color leds
int readKeys(void) {
#ifdef TEENSY35
  for (byte a=2; a<11; a++) pinMode(a, INPUT_PULLUP);
  if(digitalRead(2)==0) {delay(50); if(digitalRead(2)==0) return '0'; writeColor(1);}
  if(digitalRead(4)==0) {delay(50); if(digitalRead(4)==0) return '1'; writeColor(2);}
  if(digitalRead(7)==0) {delay(50); if(digitalRead(7)==0) return '2'; writeColor(4);}
  if(digitalRead(9)==0) {delay(50); if(digitalRead(9)==0) return '3'; writeColor(0);}
  if(digitalRead(5)==0) {delay(50); if(digitalRead(5)==0) return '4'; }
  if(digitalRead(8)==0) {delay(50); if(digitalRead(8)==0) return '5'; }
  if(digitalRead(10)==0) {delay(50); if(digitalRead(10)==0) return '6'; } 
  if(digitalRead(3)==0) {delay(50); if(digitalRead(3)==0) return '7'; } 
  return 0;
#endif
  WireBegin();
  static bool configured = false;
  if (!configured) {
    writeByte(0x21, 0x01, 0x00);
    writeByte(0x21, 0x0c, 0xff);
    writeByte(0x21, 0x00, 0xff);
    configured = true;
  }

  // any switch pressed (6 rows) ?
  writeByte(0x21, 0x13, 0xC0);
  short a = readByte(0x21, 0x12);
  if (a!=255) {
    short s;
    writeColor(-1);
    for (int i=0; i<5; i++) {   // scan 6 rows
      writeByte(0x21, 0x13, ~(1<<i));
      s = readByte(0x21, 0x12);
      writeColor(-1);
      if (s!=255) {
        a=0;
        switch(s)               // test 5 columns
        { case 0xfe: a= i+0; break;
          case 0xfd: a= i+5; break;
          case 0xfb: a= i+10; break;
          case 0xf7: a= i+15; break;
          case 0xef: a= i+20; break;
          case 0xdf: a= i+25; break;
          case 0xbf: a= i+30; break;
          default:   a= i+35; break; // multiple switches
        }
        writeColor(-1);
        WireEnd();
        return keyCodes[a];
      }
    }
  }
  writeColor(-1);
  WireEnd();
  return 0;
}

/*
Register list on 74LS173 chips:
0 = write lsb data 12-15
1 = write lsb data 8-11
2 = write msb data 4-7 (in rev2 was 8)
3 = write msb data 0-3 (was 9)
4 = write inst 12-15 (was 2)
5 = write inst 8-11 (was 3)
6 = write control L (was 10)
7 = write control H (was 11)
*/

// write Nova Data or Instruction register nibble to 74LS173 register
void WriteReg(byte chip, byte value) {
#ifdef TEENSY35
  return;
#endif
  value=~value;      // negate value to make active high
  static bool configured = false;
  if (!configured) {
    for (byte i=6;  i<9; i++) pinMode(i, OUTPUT); 
    for (byte i=18; i<22; i++) pinMode(i, OUTPUT); 
    pinMode(3, OUTPUT);
    digitalWrite(3, 1);
    configured = true;
  }

  digitalWrite(18, value&1); // output 4bit data
  digitalWrite(19, (value>>1)&1);
  digitalWrite(20, (value>>2)&1);
  digitalWrite(21, (value>>3)&1);
  
  digitalWrite(6, chip&1);     // output 3bits address
  digitalWrite(7, (chip>>1)&1);
  digitalWrite(8, (chip>>2)&1);

  delayMicroseconds(1);     // pulse SELR1 low
  digitalWrite(3, 0);
  delayMicroseconds(1);
  digitalWrite(3, 1);
}

void writeDataReg(unsigned short d)    // set data register
{ WriteReg(0, d&15);        // data L LSB
  WriteReg(1, (d>>4));      // data H LSB
  WriteReg(2, (d>>8));      // data L MSB
  WriteReg(3, (d>>12));     // data H MSB
}

void writeInstReg(byte i)    // set instruction register (only 8 Nova MSB bits used)
{ WriteReg(4, i);           // data L MSB
  WriteReg(5, (i>>4));      // data H MSB
}

void writeControlReg(byte i) // set control register (unused, always use WriteReg directly)
{ WriteReg(6, i);      // ISTP/PL/RST/X
  WriteReg(7, i>>4);   // MSTP/CON+/CONREQ/STOP
}

void wait(void) {
  delayMicroseconds(2);
}

unsigned int CurrentSwitchValue=0;

// read nova accumulator 0..3
unsigned int examineAC(int address) {
#ifdef SIMULATED
  writeData(NovaRegs[address&3]);
  return NovaRegs[address&3];
#endif
  writeInstReg(0x67+(address<<3));
  WriteReg(7, 4);
  wait();
  WriteReg(7, 0);
  wait();
  int v = readData();
  return v;
}

// read single word from nova memory or register
unsigned int examine(int address) {
  if (address>=0xfffc)
    return examineAC(address-0xfffc);
#ifdef SIMULATED
  unsigned short int w=0;
  writeAddr(address);
  if (address<16384) w = NovaMem[address];
  writeData(w);
  NovaPC = address;
  return w;
#endif
  writeInstReg(0xf9);
  writeDataReg(address);
  WriteReg(6, 0);  // connect data register to bus
  WriteReg(7, 4);  // pulse CONREQ
  wait();
  WriteReg(7, 0);  // revert to idle state
  WriteReg(6, 8);
  wait();
  int v = readData(); // read lights
  writeDataReg(CurrentSwitchValue);
  return v;
}

// write single word to nova accumulator
void depositAC(unsigned int address, unsigned int value) {
#ifdef SIMULATED
  writeData(value);
  NovaRegs[address&3] = value;
  return;
#endif
  writeInstReg(0x23+(address<<3));
  writeDataReg(value);
  WriteReg(6, 0);
  WriteReg(7, 4);
  wait();
  WriteReg(7, 0);
  wait();
  WriteReg(6, 8);
  writeDataReg(CurrentSwitchValue);
}

// write single word to nova memory or accumulator
void deposit(unsigned int address, unsigned int value) {
  if (address>=0xfffc) 
  { depositAC(address-0xfffc, value);
    return;
  }
#ifdef SIMULATED
  writeAddr(address);
  writeData(value);
  if (address>=16384) return;
  NovaMem[address] = value;
  return;
#endif
  writeInstReg(0xf9);
  writeDataReg(address);
  WriteReg(6, 0);
  WriteReg(7, 4);
  wait();
  WriteReg(7, 0);
  wait();
  writeInstReg(0xdd);
  writeDataReg(value);
  WriteReg(7, 4);
  wait();
  WriteReg(7, 0);
  wait();
  WriteReg(6, 8);
  writeDataReg(CurrentSwitchValue);
}

bool novaRunning=false;
unsigned int prevpc=0;              // used when stepping back in debugging
int count9=0;
bool SerialIO=false;               // if set serial is sent/recieved to Nova

unsigned int stopNova(void)
{ 
#ifndef SIMULATED
  novaRunning=false;
  return saved_PC;
#endif
  
  WriteReg(7, 8);
  wait();
  WriteReg(7, 0);
  wait();
  novaRunning=false;
  return readAddr();
}

// number of instructions per update of front panel
#define SIMINTERVAL 2000

// start at address a
void startNova(unsigned int a)
{
#ifdef SIMULATED
  int count;
  count9=0;
  novaRunning=true;
  prevpc=a;
  saved_PC=a;
  writeLights(1);
  while(novaRunning)
  { sim_instr(SIMINTERVAL);
    NovaPC=saved_PC;
    writeAddr(saved_PC);
    writeData(examine(saved_PC));
    writeLights(
      (novaRunning?1:0)|
      (int_req & INT_ION?2:0)|
      (novaRunning?4:0)|
      (novaRunning?8:0)|
      (0)|
      (NovaC&CBIT?32:0));

    // push '9' for about ~1 second to stop the Nova
    int k=readKeys();
    if (k=='9') 
    { count9++;
      if (count9==250000/SIMINTERVAL) break; 
    }
    if (k) processkey(k);

    if (Serial.availableForWrite())
    { //if (DEV_IS_BUSY(INT_TTO))
      if (false)
      { int a=ttobuf&0x7f;
        if (a==10 || a==13 || a>=' ') 
          Serial.write(a);
        else
        { //Serial.print("?");
          //Serial.println(a);
        }
        DEV_CLR_BUSY(INT_TTO);
        DEV_SET_DONE(INT_TTO);
        DEV_UPDATE_INTR ;
        continue;
      }
    }

    // write to TTI and respond to ctrl-c
    if ((count=Serial.available()))
    { processSerial(count);
      //if (SerialIO) return;
    }
  }

  novaRunning=false;
  SerialIO=false;
  writeLights(0);
  return;
#endif

  writeDataReg(a);
  writeInstReg(0xfb);
  WriteReg(7, 4);
  wait();
  WriteReg(7, 0);
  wait();
  writeDataReg(CurrentSwitchValue);
  novaRunning=true;
}              

// continue
// note: examine and deposit affect continue address
void continueNova(void)
{ 
#ifdef SIMULATED
  startNova(NovaPC);
  return;
#endif
  writeInstReg(0xfb);
  WriteReg(7, 6);
  WriteReg(7, 0);
  wait();
  novaRunning=true;
}              

// continue but pass value of sw to switch register (disabling hardware switches)
// note: examine and deposit affect continue address, restore it by a=readAddr() .... examine(a); continueNovaSw(int sw)
void continueNovaSw(int sw)
{ CurrentSwitchValue=sw;
#ifdef SIMULATED
  SR = sw;
  startNova(NovaPC);
  return;
#endif
  writeDataReg(CurrentSwitchValue);
  WriteReg(6, 0);
  wait();
  writeInstReg(0xfb);
  WriteReg(7, 6);
  WriteReg(7, 0);
  wait();
  WriteReg(6, 8);
  novaRunning=true;
}              

void stepNova(void)
{ 
#ifdef SIMULATED
  novaRunning = true;
  writeLights(
      (novaRunning?1:0)|
      (int_req & INT_ION?2:0)|
      (novaRunning?4:0)|
      (novaRunning?8:0)|
      (0)|
      (NovaC&CBIT?32:0));
  prevpc=NovaPC;
  saved_PC=NovaPC;
  sim_instr(1);
  NovaPC=saved_PC;
  novaRunning = false;
  writeAddr(saved_PC);
  writeData(examine(saved_PC));
  writeLights(
      (novaRunning?1:0)|
      (int_req & INT_ION?2:0)|
      (novaRunning?4:0)|
      (novaRunning?8:0)|
      (0)|
      (NovaC&CBIT?32:0));
  return;
#endif

  prevpc=readAddr();
  writeInstReg(0xff);
  WriteReg(6, 9);
  WriteReg(7, 6);
  wait();
  Serial.println(F("instruction step"));
  WriteReg(7, 0);
  WriteReg(6, 8);
}

void memstepNova(void)
{ 
#ifdef SIMULATED
  stepNova();
  return;
#endif
  
  writeInstReg(0xff);
  WriteReg(7, 7);
  wait();
  WriteReg(7, 0);
}

void resetNova(void)
{ stopNova();
  WriteReg(6, 12);
  WriteReg(7, 6);
  delay(100);
  Serial.println("reset");
  WriteReg(7, 0);
  WriteReg(6, 8);
  lcdclearline(1);
  lcdsetCursor(0,1);
  lcdprint("reset"); 
  novaRunning=false;
  examine(0);
}

// assume 4x6 font, define width (128/4) and height (32/6)
#define defaultFont u8g2_font_4x6_mf //u8g2_font_tinytim_tf
#define U8LOG_WIDTH 32
#define U8LOG_HEIGHT 5
uint8_t u8log_buffer[U8LOG_WIDTH*U8LOG_HEIGHT];

// drive 4051 multiplexer for 5 I2C displays 0=left, 4=right
void selectDisplay(byte disp) {
#ifdef TEENSY35
  return;
#endif
  static bool configured = false;
  if (!configured) {
    pinMode(9, OUTPUT);  // ENOLED0
    pinMode(10, OUTPUT); // ENOLED1
    pinMode(15, OUTPUT); // ENOLED2
    configured = true;
  }
    
  digitalWrite(9, disp&1);
  digitalWrite(10, (disp>>1)&1);
  digitalWrite(15, (disp>>2)&1);
}

bool DrawCursor=false;

void lcdprint(String text)
{ selectDisplay(0);
  u8g2.setFont(defaultFont);
  u8g2.print(text);
  u8g2.sendBuffer();
}

void lcdwrite(uint8_t c)
{ selectDisplay(0);
  u8g2.setFont(defaultFont);
  u8g2.write(c);  
  u8g2.sendBuffer();
}

int oldx=0, oldy=0;
void lcdsetCursor(int x, int y)
{ selectDisplay(0);
  u8g2.setCursor(x*4,y*7+5);
  if (DrawCursor)
  { u8g2.setDrawColor(0);
    u8g2.drawLine(oldx*4,oldy*7+6,oldx*4+3,oldy*7+6);
    u8g2.setDrawColor(1);
    u8g2.drawLine(x*4,y*7+6,x*4+3,y*7+6);
    u8g2.sendBuffer();
    oldx=x; oldy=y;
  }
}

void lcdcursor(void)
{ DrawCursor=true;
}

void lcdnoCursor(void)
{ if (DrawCursor)
  { u8g2.setDrawColor(0);
    u8g2.drawLine(oldx*4,oldy*7+6,oldx*4+3,oldy*7+6);
    u8g2.setDrawColor(1);
    u8g2.sendBuffer();
  }
  DrawCursor=false;
}

void lcdclear(void)
{ selectDisplay(0);
  u8g2.clear();
  lcdsetCursor(0,0);
}

void lcdclearline(int y)
{ selectDisplay(0);
  u8g2.setDrawColor(0);
  u8g2.drawBox(0,y*7,128,y*7+6);
  u8g2.setDrawColor(1);
}

// display text with large font on selected arbitrary display
void display(byte disp, String text)
{ selectDisplay(disp);
  u8g2.clearBuffer(); 
  u8g2.setFont(u8g2_font_logisoso16_tr);
  u8g2.setCursor(8, 29);
  u8g2.print(text);
  u8g2.sendBuffer();
  u8g2.setFont(defaultFont);  
}

// make hex string with leading zeros
String toHex(unsigned int v) {
  String s;
  if (v<0x1000) s += "0";
  if (v<0x0100) s += "0";
  if (v<0x0010) s += "0";
  s += String(v, HEX);
  return s;
}

// make hex string with leading zeros
String toHex2(unsigned int v) {
  String s;
  if (v<0x0010) s += "0";
  s += String(v, HEX);
  return s;
}

String toOct(unsigned int v) {
  String s;
  if (v<0x8000) s += "0";
  if (v<0x1000) s += "0";
  if (v<0x0200) s += "0";
  if (v<0x0040) s += "0";
  if (v<0x0008) s += "0";
  s += String(v, OCT);
  return s;
}

// convert n digit hex string in buffer
unsigned int readHex(char *buf, byte n)
{ unsigned int r=0;
  for (int i=0; i<n; i++)
  { r = r<<4;
    if (buf[i]>='a') r = r+buf[i]-'a'+10;
    else if (buf[i]>='A') r = r+buf[i]-'A'+10;
    else r = r+buf[i]-'0';
  }
  return r;
}

// read octal string in buffer
unsigned int readOct(String s, int pos)
{ unsigned int r=0;
  for (unsigned int i=pos; i<s.length(); i++)
  { if (s[i]<'0' || s[i]>'7') break;
    r = r<<3;
    r = r+s[i]-'0';
  }
  return r;
}

/////////////////////// disassembler ////////////////////////
// part of disassembler - print shift in operate instruction
String printShift(unsigned int s) {
  if (s==1) return String("L");
  else if (s==2) return String("R");
  else if (s==3) return String("S"); // byte swap
  else return("");
}

// part of disassembler - print carry op in operate instruction
String printCarry(unsigned int s) {
  if (s==1) return String("Z");
  else if (s==2) return String("O");
  else if (s==3) return String("C");
  else return String("");
}

// part of disassembler - print noload in operate instruction
String printNoload(unsigned int s) {
  if (s==1) return String("#");
  else return String("");
}

// part of disassembler - print skip part of operate instruction
String printSkip(unsigned int s) {
  if (s==1) return String("skp");
  if (s==2) return String("szc");
  if (s==3) return String("snc");
  if (s==4) return String("szr");
  if (s==5) return String("snr");
  if (s==6) return String("sez");
  if (s==7) return String("sbn");
  return String("");
}

// part of disassembler - print target of memory access instruction
String printTarget(unsigned int mode, unsigned int disp, int octalmode) {
  String s=" ";
  if (mode==0) { s += String(disp&255, octalmode); }
  if (mode==1) s += ("pc"); 
  if (mode==2) s += ("ac2"); 
  if (mode==3) s += ("ac3");
  if (mode>=4) s += ("@");
  if (mode==4) { s += String(disp&255, octalmode); }
  if (mode==5) s += ("pc"); 
  if (mode==6) s += ("ac2"); 
  if (mode==7) s += ("ac3");
  if (mode==1 or mode==2 or mode==3 or mode==5 or mode==6 or mode==7) 
  { if (disp&0x80)
    { s += ('-'); s += String(128-(disp&127), octalmode); }
    else
    { s += ('+'); s += String(disp&127, octalmode); }
  }
  return s;
}

// part of disassembler - print transfer and control in IOT instruction
String printIOT(unsigned int tr, unsigned int sk) {
  String s = "";
  if (tr==0) s += ("NIO");
  if (tr==1) s += ("DIA");
  if (tr==2) s += ("DOA");
  if (tr==3) s += ("DIB");
  if (tr==4) s += ("DOB");
  if (tr==5) s += ("DIC");
  if (tr==6) s += ("DOC");
  if (tr==7)
  { s += ("SKP");
    if (sk==0) s += ("BN");
    if (sk==1) s += ("BZ");
    if (sk==2) s += ("DN");
    if (sk==3) s += ("DZ");
  }
  else  // control part
  { if (sk==0) s += ("");
    if (sk==1) s += ("S");
    if (sk==2) s += ("C");
    if (sk==3) s += ("P");
  }
  return s;
}

#define HALT       063077

// System calls (these all are functional HALT instructions, interpreted by Arduino program)
#define INFO       077377 // show debug information on LCD
#define PUTC       077277 // output character to LCD and serial
#define GETC       077177 // get character from serial (/ mode) or keypad (9-5 mode)
#define READBLOCK  077077 // read 64 word block A0 from device (EEPROM) to address A2
#define WRITEBLOCK 073377 // write 64 word block A0 to device (EEPROM) from address A2
#define WRITELED   073277 // A0 bit 0 sets Arduino LED
#define MESSAGE    073177 // Write text string with %0..%3 substituted for AC0..3
#define GPIO       073077 // High bits define data direction (O=out), low bits value
//#define SKIPBUSYZ  (MOV(3,3)+NOLOAD+SKP) // Always skip
#define SKIPDONE   067377 // skip when character available
#define DELAY      067277 // Delay A0 ms, showing A1 on lights
#define ADC        067177 // Read A0 from teensy
// 6 are open 06[3,7][1-3]77 except 063077; maybe add 
// HWMUL, HWDIV, DEVICESEL, SKIPBUSYZ (always skip)

// Disassemble entire instruction and return
String printDisas(unsigned int v, int octalmode) {
  String s(" ");
  unsigned int mref = (v>>11)&0x1f;
  unsigned int opcode = (v>>8)&0x7;

  // system calls
       if (v==GETC)             s+=(".GETC");  
  else if (v==PUTC)             s+=(".PUTC");  
  else if (v==INFO)             s+=(".INFO");  
  else if (v==WRITELED)         s+=(".WRITELED");
  else if (v==READBLOCK)        s+=(".READBLOCK");
  else if (v==WRITEBLOCK)       s+=(".WRITEBLOCK");
  else if (v==MESSAGE)          s+=(".MESSAGE");
  else if (v==GPIO)             s+=(".GPIO");
//  else if (v==SKIPBUSYZ)        s+=(".SKIPBUSYZ");
  else if (v==DELAY)            s+=(".DELAY");
  else if (v==ADC)              s+=(".ADC");
  else if (v==HALT)             s+=("HALT");    //doc0, 4 bits free
  else if ((v&0xe73f)==0x663f)  s+=(".HALT");   // unused system call

  // cpu control instructions
  else if ((v&0xff3f)==0x653f)  s+=("IORST"); //dicc0
  else if ((v&0xe73f)==0x613f) {s+=("READS");s+=String(mref&3);}//dia#
  else if (v==0x607f) s+=("INTEN"); // nios0
  else if (v==0x60bf) s+=("INTDS"); // nioc0
  else if (v==0x673f) s+=("SKPBN CPU");
  else if (v==0x677f) s+=("SKPBZ CPU");
  else if (v==0x67bf) s+=("SKPDN CPU");
  else if (v==0x67ff) s+=("SKPDZ CPU");
  else if ((v&0xe73f)==0x643f) {s+=("MSKO");s+=String(mref&3);}//dob#
  else if ((v&0xe73f)==0x633f) {s+=("INTA");s+=String(mref&3);}//dib#

  // data access instructions
  else if (mref==0) { s+=("JMP"); s+=printTarget((v&0x700)>>8, v&0xff, octalmode); }
  else if (mref==1) { s+=("JMS"); s+=printTarget((v&0x700)>>8, v&0xff, octalmode); }
  else if (mref==2) { s+=("ISZ"); s+=printTarget((v&0x700)>>8, v&0xff, octalmode); }
  else if (mref==3) { s+=("DSZ"); s+=printTarget((v&0x700)>>8, v&0xff, octalmode); }
  else if ((mref&0x1c)==4) { s+=("LDA"); s+=String(mref&3); s+=printTarget((v&0x700)>>8, v&0xff, octalmode); }
  else if ((mref&0x1c)==8) { s+=("STA"); s+=String(mref&3); s+=printTarget((v&0x700)>>8, v&0xff, octalmode); }

  // IOT instructions
  else if ((mref&0x1c)==12)
  { s+=printIOT((v&0x700)>>8, (v&0xc0)>>6); 
    s+=String(mref&3); 
    s+=(" "); 
    s+=String(v&0x3f,octalmode); 
  }

  // operate instructions
  else if ((mref&0x10)==16)
  { if (opcode==0)  s+=("CMP");
    if (opcode==1)  s+=("NEG");
    if (opcode==2)  s+=("MOV");
    if (opcode==3)  s+=("INC");
    if (opcode==4)  s+=("ADC");
    if (opcode==5)  s+=("SUB");
    if (opcode==6)  s+=("ADD");
    if (opcode==7)  s+=("AND");
    s+=printNoload((v&0x8)>>3);
    s+=String((mref&12)>>2); // source
    s+=String(mref&3);       // destination
    s+=printShift((v&0xc0)>>6);
    s+=printCarry((v&0x30)>>4);
    s+=printSkip(v&7);
  }
  else 
  { s+=('?'); s+=String(v); } // unknown instruction

  return s;
}

// go from 16 bits to 21 bits mini assembler instruction format
unsigned long unpackassemble(unsigned int v)
{ unsigned int mref = (v>>11)&0x1f;
  unsigned long opcode = (v>>8)&0x7;
  unsigned long insttype;
  unsigned long op=0;
  unsigned long a=0;
  unsigned long b=0;
  unsigned long dest=0;

  if      ((v&0xff3f)==0x653f)  { insttype=1; op=0;}
  else if ((v&0xe73f)==0x663f)  { insttype=1; op=1;}
  else if ((v&0xe73f)==0x613f)  { insttype=1; op=2; a=mref&3; }
  else if (v==0x607f)           { insttype=1; op=3;}
  else if (v==0x60bf)           { insttype=1; op=4;}
  else if ((v&0xe73f)==0x643f)  { insttype=1; op=5; a=mref&3; }
  else if ((v&0xe73f)==0x633f)  { insttype=1; op=6; a=mref&3 ;}

  if      (mref==0)        { insttype=2; op=mref;   b=(v&0x700)>>8; dest=v&0xff; } //jmp`
  else if (mref==1)        { insttype=2; op=mref;   b=(v&0x700)>>8; dest=v&0xff; } //jms
  else if (mref==2)        { insttype=4; op=mref-2; b=(v&0x700)>>8, dest=v&0xff; } // isz
  else if (mref==3)        { insttype=4; op=mref-2; b=(v&0x700)>>8, dest=v&0xff; } // dsz
  else if ((mref&0x1c)==4) { insttype=3; op = ((mref&0x1c)-4)/4; a=mref&3; b=(v&0x700)>>8; dest= v&0xff;} // lda
  else if ((mref&0x1c)==8) { insttype=3; op = ((mref&0x1c)-4)/4; a=mref&3; b=(v&0x700)>>8; dest= v&0xff;} // sta
  else if ((mref&0x10)==16)
  { insttype=5;
    a = (mref&12)>>2;
    b = mref&3;
    unsigned long noload = (v&0x8)>>3;
    unsigned long shift = (v&0xc0)>>6;
    unsigned long carry = (v&0x30)>>4;
    unsigned long skip = v&7;
    return (insttype<<18)+(opcode<<15)+(a<<12)+(b<<9)+(shift<<6)+(noload<<5)+(carry<<3)+skip;
  }
  else if ((mref&0x1c)==12)
  { op   = (v&0x700)>>8;
    a    = (v&0x1800)>>11; 
    b    = (v&0xc0)>>6; 
    dest =  v&0x3f; 
    insttype=6;
    if (op==7) { insttype=7; op=0; a=0; }
  }
  return (insttype<<18)+(op<<15)+(a<<12)+(b<<9)+dest;
}

unsigned int I1[7] = {0x653f, 0x663f, 0x613f, 0x607f, 0x60bf, 0x643f, 0x633f};

// go from 21 bits mini assembler instruction format to 16 bit native format
unsigned int packassemble(unsigned long v)
{ unsigned int insttype = (v&07000000)>>18;
  unsigned int op       = (v&00700000)>>15;
  unsigned int a        = (v&00070000)>>12;
  unsigned int b        = (v&00007000)>>9;
  unsigned int dest     = (v&00000777);
  unsigned int shft     = (v&00000700)>>6;
  unsigned int crry     = (v&00000030)>>3;
  unsigned int nold     = (v&00000040)>>5;
  unsigned int skip     = (v&00000007);


  if (insttype==1 && op==2) return I1[op]+(a<<11);
  if (insttype==1 && op <7) return I1[op];
  if (insttype==2) return ((op  )<<11)+(b<<8)+dest;
  if (insttype==3) return ((op+1)<<13)+(a<<11)+(b<<8)+dest;
  if (insttype==4) return ((op+2)<<11)+(b<<8)+dest;
  if (insttype==5) return 0x8000+((op)<<8)+(a<<13)+(b<<11)+(shft<<6)+(crry<<4)+(nold<<3)+skip;
  if (insttype==6) return 0x6000+((op)<<8)+(a<<11)+(b<<6)+(dest&077);
  if (insttype==7) return 0x6000+((7)<<8)+(0<<11)+(b<<6)+(dest&077);
  return 0;
}

// Disassemble 21 bits instruction, mini assembler style, and print to lcd
String printMiniDisas(unsigned long v, int octalmode) {
  return printDisas(packassemble(v), octalmode);
} 

void printAssemblyHelp(unsigned long v, int noctal)
{ int type = (v&07000000)>>18;
  printHelp("");

  if (noctal==0)            printHelp(F("1-7= special jmp ld/st inc ops I/O skip"));

  if (noctal==1 && type==1) printHelp(F("0-6 IORST HLT READS INTEN INTD MSKO INTA"));
  if (noctal==1 && type==2) printHelp(F("0=JMP 1=JMS"));
  if (noctal==1 && type==3) printHelp(F("0=LDA 1=STA"));
  if (noctal==1 && type==4) printHelp(F("0=ISZ 1=DSZ"));
  if (noctal==1 && type==5) printHelp(F("0..7=CMP NEG MOV INC ADC SUB ADD AND"));
  if (noctal==1 && type==6) printHelp(F("0..6=NIO DIA DOA DIB DOB DIC DOC"));
  if (noctal==1 && type==7) printHelp(F("IO status 0=skip"));

  if (noctal==2 && (type==1||type==3)) 
                            printHelp(F("accu 0..3 = ac0..ac3"));
  if (noctal==2 && type==5) printHelp(F("source accu 0..3 = ac0..ac3"));

  if (noctal==3 && type>=2 && type<=4) 
                            printHelp(F("0=abs 1=pc+ 2=ac2+ 3=ac3+ +4=@"));
  if (noctal==3 && type==5) printHelp(F("dest accu 0..3 = ac0..ac3"));
  if (noctal==3 && type==6) printHelp(F("IO func 0=none 1=set 2=clr 3=puls"));
  if (noctal==3 && type==7) printHelp(F("skip 0=busy 1=!busy 2=done 3=!done"));
  
  if (noctal==4 && type==5) printHelp(F("shift 0=none 1=L 2=R 3=bswap"));
  if (noctal==5 && type==5) printHelp(F("carry 0=as is 1=Z 2=O 3=C +4=noload"));
  if (noctal==6 && type==5) printHelp(F("skip 0..7=no yes NC C Z NZ NCZ CZ"));
  
  if (noctal>=4 && type>1 && type<=4) 
                            printHelp(F("offset +0..177 pos 377..200 neg"));
  if (noctal>=4 && type>=6) printHelp(F("device 000..077"));
}

////////////////////////////////////////////////////
// print octal on LCD with leading zeros
void lcdPrintOctal(unsigned int v) {
 lcdprint(toOct(v));
}

// print octal on LCD with leading zeros followed by space and two ascii characters
void lcdPrintOctalAscii(unsigned int v) {
 lcdPrintOctal(v);
 lcdprint(char(32));
 lcdprint(char(v>>8));
 lcdprint(char(v&255));
}

// print hex on LCD with leading zeros
void lcdPrintHex(unsigned int v) {
 lcdprint(toHex(v));
}

// print decimal on LCD with leading zeros
void lcdPrintDecimal(unsigned int v) {
 if (v<10000) lcdprint(0);
 if (v<1000) lcdprint(0);
 if (v<100) lcdprint(0);
 if (v<10) lcdprint(0);
 lcdprint(v);
}

// print long octal (21 bits) on LCD with leading zeros
void lcdPrintLongOctal(unsigned long v) {
 if (v<0x40000) lcdprint(0);
 if (v<0x08000) lcdprint(0);
 if (v<0x01000) lcdprint(0);
 if (v<0x00200) lcdprint(0);
 if (v<0x00040) lcdprint(0);
 if (v<0x00008) lcdprint(0);
 lcdprint(String(v, OCT));
}

String saveHelp="xx";
void printHelp(String a)
{ if (a==saveHelp) return;
  saveHelp=a;
  lcdclearline(3);
  lcdsetCursor(0, 3);
  if (a!="") lcdprint(a.substring(0, 32));
  lcdclearline(4);
  lcdsetCursor(0, 4);
  if (a!="") lcdprint(a.substring(32));
}

////////////////////////////////////////////////////
// mini debugger display on lcd in single step mode
void lcdPrintDebug(void) {
  lcdclear(); // clear screen
#ifdef SIMULATED
  unsigned int pc = NovaPC;
  unsigned int carry = NovaC!=0;
  unsigned int in = NovaMem[NovaPC], a0, a1, a2=0, a3=0;
#else
  unsigned int pc = readAddr()&0x7fff;
  unsigned int carry = readAddr()&0x8000;
  unsigned int in = readData(), a0, a1, a2=0, a3=0;
#endif
  lcdsetCursor(0,0);    // print 4 accumulators
  lcdprint("ac0:");
  lcdPrintOctal(a0=examineAC(0));
  lcdprint(" 1:");
  lcdPrintOctal(a1=examineAC(1));
  lcdprint(" 2:");
  lcdPrintOctal(a2=examineAC(2));
  lcdprint(" 3:");
  lcdPrintOctal(a3=examineAC(3));
  lcdprint(" ");
  if (carry)
    lcdprint("C");
  else
    lcdprint(".");
  in = examine(pc);
  lcdsetCursor(0,1);
  lcdPrintOctal(pc);    // print address
  lcdsetCursor(6,1);
  lcdprint(printDisas(in, OCT));    // disassemble instruction

  int mref = (in>>11)&0x1f;
  int b=(in&0x700)>>8;
  int dest=in&0xff;
  bool target=false;
  int indirect=0;
  unsigned int t=0;
    
  if      (mref<=1)        { target = true; } // jmp, jms
  else if (mref<=3)        { target = true; indirect=1; } // isz, dsz
  else if ((mref&0x1c)==4) { target = true; indirect=1; } // lda
  else if ((mref&0x1c)==8) { target = true; } // sta

  if (target)
  { switch(b)
    { case 1: case 5: if (dest&0x80) t = pc-(128-(dest&127)); else t=pc+dest; break;
      case 2: case 6: if (dest&0x80) t = a2-(128-(dest&127)); else t=a2+dest; break;
      case 3: case 7: if (dest&0x80) t = a3-(128-(dest&127)); else t=a3+dest; break;
      case 0: case 4: t=dest; break;     
    }

    if (b>3) indirect++;
    lcdprint(" ");
    if (b>3) lcdprint("@");
    if (b>0)lcdPrintOctal(t);
    for (int i=0; i<indirect; i++)
    { if (b>3) do t=examine(t); while (t&0x8000);
      else t=examine(t);
    }
         
    if (indirect)
    { lcdprint("->");
      lcdPrintOctal(t);
    }
  }

  examine(pc);
}

// mini debugger display on serial interface
void serialDebug(int mode) {
#ifdef SIMULATED
  unsigned int pc = NovaPC;
  unsigned int carry = NovaC!=0;
  unsigned int in = NovaMem[NovaPC], a0, a1, a2=0, a3=0;
#else
  unsigned int pc = readAddr()&0x7fff;
  unsigned int carry = readAddr()&0x8000;
  unsigned int in = readData(), a0, a1, a2=0, a3=0;
#endif
  a0=examineAC(0);
  a1=examineAC(1);
  a2=examineAC(2);
  a3=examineAC(3);
  if (mode&1)
  { Serial.print("ac0:");
    Serial.print(toOct(a0));
    Serial.print(" 1:");
    Serial.print(toOct(a1));
    Serial.print(" 2:");
    Serial.print(toOct(a2));
    Serial.print(" 3:");
    Serial.print(toOct(a3));
    Serial.print(" ");

    if (carry)
      Serial.println("C");
    else
      Serial.println(".");
  }

  if (mode&2)
  { in = examine(pc);
    Serial.print(toOct(pc));    // print address
    Serial.print(printDisas(in, OCT));    // disassemble instruction
  
    int mref = (in>>11)&0x1f;
    int b=(in&0x700)>>8;
    int dest=in&0xff;
    bool target=false;
    int indirect=0;
    unsigned int t=0;
  
    if      (mref<=1)        { target = true; } // jmp, jms
    else if (mref<=3)        { target = true; indirect=1; } // isz, dsz
    else if ((mref&0x1c)==4) { target = true; indirect=1; } // lda
    else if ((mref&0x1c)==8) { target = true; } // sta
  
    if (target)
    { switch(b)
      { case 1: case 5: if (dest&0x80) t = pc-(128-(dest&127)); else t=pc+dest; break;
        case 2: case 6: if (dest&0x80) t = a2-(128-(dest&127)); else t=a2+dest; break;
        case 3: case 7: if (dest&0x80) t = a3-(128-(dest&127)); else t=a3+dest; break;
        case 0: case 4: t=dest; break;     
      }
  
      if (b>3) indirect++;
      Serial.print(" ");
      if (b>3) Serial.print("@");
      if (b>0) Serial.print(toOct(t));
  
      for (int i=0; i<indirect; i++)
      { if (b>3) do t=examine(t); while (t&0x8000);
        else t=examine(t);
      }
           
      if (indirect)
      { Serial.print("->");
        Serial.print(toOct(t));
      }
    }
  }
  examine(pc);
}

// TODO: detect
unsigned short memsize=16384;

void tests(int func)
{ while (readKeys());

  // register test: disconnect boards from nova and connect data req or inst req to gnd
  if (func==0) // 1st switch up
  { for(int count=0; count<65536; count++)
    { lcdsetCursor(0,1);
      lcdPrintOctal(count);
      lcdprint("  reg test ");
      lcdPrintOctal(readLights());
      writeDataReg(32768>>(count&15));
      writeInstReg(1<<(count&15));
      WriteReg(6, (count&7)); // keep connected to reg
      WriteReg(7, count/16);

      // test that read data gives back data (only if hand enabled)
      digitalWrite(13, readData()!=((unsigned)32768>>(count&15)));
      delay(100);
      //debugPrint(a0, a1, 11, 11, readAddr(), readData()); 
      if (readKeys() != 0) break;
    }
  }

  // full memory dump
  else if (func==1) // 2nd switch up
  { stopNova();
    lcdsetCursor(0,1);
    lcdprint("     dump active");
    lcdsetCursor(0,1);
    for(int a=0; a<memsize; a++)
    { if ((a&511)==511) lcdprint("#");
      int v = examine(a);
      Serial.print(toHex(a));
      Serial.print(":");
      Serial.println(toHex(v));
    }
    lcdsetCursor(0,1);
    lcdprint("dump ready      ");
  }

  // small memory test, address 0 only
  else if (func==2) // 3rd switch up
  { stopNova();
    lcdsetCursor(0,1);
    lcdprint("     mt0 active");
    for(unsigned int a=0; a<65535*32; a++)
    { unsigned int v = random(65535); // a&1?0x5555:0xaaaa;
      unsigned int ad = 0; // a&16383;
      deposit(ad, v);
      unsigned int c = examine(ad);
      digitalWrite(13, v!=c);
    }
    lcdsetCursor(0,1);
    lcdprint("mt0 ready      ");
  }

  // small memory test, address 0 only
  else if (func==3) // 4rd switch up
  { stopNova();
    lcdsetCursor(0,1);
    lcdprint("     mt1 active");
    for(unsigned int a=0; a<65535*32; a++)
    { deposit(0, 0); // drive inhibit
    }
    lcdsetCursor(0,1);
    lcdprint("mt1 ready      ");
  }

  // small memory test, address 0 only
  else if (func==4) // 5th switch up
  { stopNova();
    lcdsetCursor(0,1);
    lcdprint("     mt2 active");
    for(unsigned int a=0; a<65535*32; a++)
    { deposit(0, 0xffff); // no inhibits driven
    }
    lcdsetCursor(0,1);
    lcdprint("mt2 ready      ");
  }
  else if (func==5) // test write/read all memory
  { while(1) {
      int i=0; String s="";
      for (i=8192; i<memsize; i+=64) {
        deposit(i, i);
      }
      for (i=8192; i<memsize; i+=64) {
        int v = examine(i);
        if (v==i) s+='.'; else s+='X';
      }  
      Serial.println(s);
    }
  }
  else if (func==6) // Continue passing virtual switches
  { continueNovaSw(0x6666);
    lcdsetCursor(0,1);
    lcdprint("sent 6666 to READS");
    delay(200);
  }
  else if (func==17) // Copy prog1..4 to NOVA
  { stopNova();
    //assemble(0, prog1);
    //assemble(050, prog2);
    //assemble(0100, prog3);
    //assemble(0140, prog4);
    // assemble(0400, prog4); // force PC relative addressing
    lcdsetCursor(0,1);
    lcdprint("loaded prog1..4");
    delay(200);
  }
  else if (func==8)
  { stopNova();
    lcdsetCursor(0,1);
    lcdprint("     mtfull active");
    for(unsigned int a=0; a<65535*32; a++)
    { unsigned int ad = a; // a&16383;
      while(ad>=memsize) ad-=memsize;
      unsigned int org = examine(ad);
      unsigned int v = random(65535); // a&1?0x5555:0xaaaa;
      deposit(ad, v);
      unsigned int c = examine(ad);
      digitalWrite(13, v!=c);
      deposit(ad, org);
    }
    lcdsetCursor(0,1);
    lcdprint("mtfull ready      ");
  }
  else if (func==7)
  { int i=0;
    while (1)
    { int sw = readSwitches();

      writeData((0x8000>>(i&15)) ^ sw);
      writeAddr(1<<(i&15));
      writeLights(1<<(i&7));
      writeDataReg(i<<8);
      writeInstReg(i);
      i++;
      display(0, String(i));
      delay (50);
      if (readKeys()) break;
    }
  }
}

// read 128 byte block from EEPROM to Nova memory A
void readBlockfromEEPROM(int block, unsigned int A)
{ writeColor(2);
  if (block<4)
  { unsigned int address=block*128;
    for (int i=0; i<64; i++)
    { deposit(A+i, EEPROM.read(address+i*2)<<8|EEPROM.read(address+i*2+1));
    }
  }
  else
  { int deviceaddress = 0x50;
    if (block>515) deviceaddress+=4;
    unsigned int address=(block-4)*128; // overflow is OK needs 16 bit
    unsigned char buffer[16];
    for(int j=0; j<8; j++)
    { i2c_eeprom_read_buffer(deviceaddress, address+j*16, buffer, 16);
      for (int i=0; i<8; i++)
      { deposit(A+i+j*8, (buffer[i*2]<<8)|buffer[i*2+1]);
      }
    }
  }
  writeColor(0);
}

// write 128 byte block from EEPROM to Nova memory A
void writeBlocktoEEPROM(int block, unsigned int A)
{ writeColor(1);
  if (block<4)
  { int address=block*128;
    for (int i=0; i<64; i++)
    { unsigned short s=examine(A+i);
      EEPROM.write(address+i*2, s>>8);
      EEPROM.write(address+i*2+1, s&255);
    }
  }
  else
  { int deviceaddress = 0x50;
    if (block>515) deviceaddress+=4;
    unsigned int address=(block-4)*128; // overflow is OK needs 16 bit
    byte buffer[26];
    for (int j=0; j<8; j++)
    { for (int i=0; i<8; i++)
      { unsigned short s=examine(A+j*8+i);
        buffer[i*2]=s>>8;
        buffer[i*2+1]=s&255;
      }
      i2c_eeprom_write_page(deviceaddress, address+j*16, buffer, 16);
      delay(5);
    }
  }
  writeColor(0);
}

String store()
{ unsigned short a = 0;
  unsigned short b = 1028-memsize/64;
  unsigned short c = memsize/64;
  unsigned short s=a;
  for (int block=b; block<b+c; block++,a+=64)
    writeBlocktoEEPROM(block, a);
  Serial.println("saved memory "+toOct(s)+ " total of " + c + " blocks");
  examine(NovaPC);
  return "";
}

String restore()
{ unsigned short a = 0;
  unsigned short b = 1028-memsize/64;
  unsigned short c = memsize/64;
  unsigned short s=a;
  for (int block=b; block<b+c; block++,a+=64)
    readBlockfromEEPROM(block, a);
  Serial.println("loaded memory "+toOct(s)+ " with " + c + " blocks");
  examine(NovaPC);
  return "run "+toOct(a);
}

// -------------------- keyboard interface description ---------------------
//
// 9 mode (press long from in decimal or I/O mode)
// 0: examine mode
// 1: decimal mode
// 2: mini assembler mode
// 3: debug mode
// 4: setup mode --> 0=small LCD, 1=large LCD
// 5: I/O mode: keyboard and lcd connected to memory mapped I/O of Nova
// 6: Test mode
// 7: Save core mode
// 8: Load core mode
// 9: Run

// 0..7 --> enter address mode; just display address (kbmode==1)
// *    --> examine ac (0..3) or examime memory (00..03..4..high)
// 8 backspace (not in decimal mode)

// * examine next; display address and disassembly
// 8 examine previous (not in decimal mode)
    
// #    --> enter data mode; display cursor on data value (kbmode==2)
// 8 backspace (not in decimal mode)
// 9 forward space (not in decimal mode)
// # deposit
// * ignore

// debug mode #; display all registers and next instruction
// 8 step back; move to previous instruction

// setup mode
// 0..6 sets mode
// 7=save to EEPROM, 8=load from EEPROM, 9=run/stop

// IO mode: 9 (long) enters setup mode
// any character on keypad is written to Nova location 040
// character written to Nova location 042 is displayed on LCD and serial
    
// test mode
// 0..7 selects tests (7=copy test program to nova)

int kbmode=0, noctal;               // mode for keypad 1=address, 2=data
unsigned int octalval;             // currently entered octal data
unsigned short octaladdress;          // last used octal address from keypad/front panel
unsigned int opmode=0;              // opmode, set with key 9
int debugging=0;                    // set after single instruction step
unsigned short haltInstruction, haltA0, haltAddress;
unsigned int core_lengths[] = {4, 128, 128, 128, 128, 512}; // in blocks of 64 words

// Addresses for memory mapped I/O
#define CHARIN 040   // input to nova
#define CHAROUT 042  // output from nova

void processswitches(short kbkey)
{ if (kbkey=='A') depositAC(0, readSwitches());
  if (kbkey=='C') depositAC(1, readSwitches());
  if (kbkey=='E') depositAC(2, readSwitches());
  if (kbkey=='G') depositAC(3, readSwitches());
  if (kbkey=='B') writeData(examineAC(0));
  if (kbkey=='D') writeData(examineAC(1));
  if (kbkey=='F') writeData(examineAC(2));
  if (kbkey=='H') writeData(examineAC(3));
  if (kbkey=='I') resetNova();
  if (kbkey=='J') writeAddr(stopNova());
  if (kbkey=='K') {SerialIO=true; startNova(readSwitches()); }
  if (kbkey=='L') {SerialIO=true; continueNova(); }
  if (kbkey=='M') {deposit(NovaPC,readSwitches()); writeAddr(NovaPC); writeData(readSwitches());}
  if (kbkey=='N') {deposit(++NovaPC,readSwitches()); ; writeAddr(NovaPC); writeData(readSwitches());}
  if (kbkey=='O') {writeData(examine(NovaPC=readSwitches())); writeAddr(NovaPC);}
  if (kbkey=='P') {writeData(examine(++NovaPC)); writeAddr(NovaPC);}
  if (kbkey=='Q') memstepNova();
  if (kbkey=='R') stepNova();
  if (kbkey=='S') store();
  if (kbkey=='T') restore();
}

void processkey(short kbkey)
{ /////////////////////////// keypad pressed /////////////////////////

  if (kbkey=='*') kbkey=10;
  else if (kbkey=='#') kbkey=12;
  else if (kbkey=='0') kbkey=11;
  else if (kbkey<='9') kbkey-='0';
  else {
    processswitches(kbkey);
    return;
  }

  // octal key or numerical key in decimal mode?
  bool isoct = ((kbkey>=1 && kbkey<=7) or kbkey==11);
  if (opmode==1)
    isoct = isoct or kbkey==8 or kbkey==9;

  if (isoct && kbmode<=1 && opmode<=3) // octal key: start or continue address mode
  { if (kbmode==0)
    { kbmode=1;
      octalval=0;
      noctal=0;
      printHelp("* = goto; 8 = backspace");
    }

    int kb=kbkey;
    if (kb==11) kb=0;

    if (noctal==0)
    { octalval=0;
      lcdclearline(0); 
      lcdnoCursor();
      if (opmode==1)
        printHelp("* = goto");
      else
        printHelp("* = goto; 8 = backspace");
    }

    lcdsetCursor(noctal,0);
    lcdprint(kb); octalval = (opmode==1?10:8)*octalval+kb; noctal++; 
    lcdnoCursor();
  }
  else if (kbkey==8 && kbmode==1 && noctal>0 && opmode<3) // backspace in address mode
  { noctal--;
    octalval = octalval>>3;
    lcdsetCursor(noctal,0);
    lcdprint(" ");
  }

  else if (isoct && kbmode==2 && opmode==0)   //  octal key in edit data mode
  { int kb=kbkey;
    if (kb==11) kb=0;
    int pos=(5-noctal)*3;
    octalval = (octalval&(~(7<<pos)))+(kb<<pos); noctal++; 
    octalval = octalval & 0xffff;
    lcdsetCursor(0,0);
    lcdPrintOctal(octaladdress);
    lcdprint(":");
    lcdPrintOctal(octalval);
    lcdclearline(1);
    lcdsetCursor(0,1);
    if (octaladdress<0xfffc) 
    { lcdprint("      :");
      lcdprint(printDisas(octalval, 8));
    }
    else 
    { lcdprint("ac");
      lcdprint(octaladdress-0xfffc);
    }
    if (noctal>5) noctal=0;
    lcdcursor();
    lcdsetCursor(7+noctal,0);
  }

  else if (isoct && kbmode==2 && opmode==1)   //  numeric key in decimal mode
  { int kb=kbkey;
    if (kb==11) kb=0;
    octalval = 10*octalval + kb;
    noctal++; 
    octalval = octalval & 0xffff;
    lcdsetCursor(0,0);
    lcdPrintDecimal(octaladdress);
    lcdprint(":");
    lcdprint(octalval);
    lcdclearline(1);
    lcdsetCursor(0,1);
    if (octaladdress>=0xfffc) 
    { lcdprint("ac");
      lcdprint(octaladdress-0xfffc);
    }
    if (noctal>6) noctal=0;
    lcdnoCursor();
  }

  else if (isoct && kbmode==2 && opmode==2)   //  octal key in assembly mode
  { unsigned long kb=kbkey;
    if (kb==11) kb=0;
    int pos=(6-noctal)*3;
    octalval = (octalval&(~((unsigned long)7<<pos)))+(kb<<pos); noctal++; 
    octalval = octalval & 0xffffff;
    lcdsetCursor(0,0);
    lcdPrintOctal(octaladdress);
    lcdprint(":");
    lcdPrintLongOctal(octalval);
    lcdclearline(1);
    lcdsetCursor(0,1);
    if (octaladdress<0xfffc) 
    lcdprint("      :");
    lcdprint(printMiniDisas(octalval, 8));
    if (noctal>6) noctal=0;
    printAssemblyHelp(octalval, noctal);
    lcdcursor();
    lcdsetCursor(7+noctal,0);
  }

  else if (kbkey==8 && kbmode==2 && opmode<=2)  // arrow back data mode
  { if (noctal==0) noctal=opmode?6:5; else noctal--;
    lcdcursor();
    lcdsetCursor(7+noctal,0);
    if (opmode==2) printAssemblyHelp(octalval, noctal);
  }
  else if (kbkey==9 && kbmode==2 && opmode<=2)  // arrow forward data mode
  { noctal++; if (noctal>(opmode?6:5)) noctal=0;
    lcdcursor();
    lcdsetCursor(7+noctal,0);
    if (opmode==2) printAssemblyHelp(octalval, noctal);
  }

  else if ((kbkey==10 && opmode<=3) or                        // * = examine / examine next
           (kbkey==8 && kbmode==1 && noctal==0 && opmode<=2)) // 8 = examine previous
  { if (kbmode==2) ; //
    else if (kbkey==8) octaladdress--;
    else if (noctal==0) octaladdress++;
    else if (noctal==1 && octalval<4) octaladdress = 0xfffc + (octalval&3);
    else octaladdress = octalval;
    lcdclearline(0);
    lcdsetCursor(0,0);
    if (opmode==1)
      lcdPrintDecimal(octaladdress); 
    else
      lcdPrintOctal(octaladdress); 
    stopNova();
    lcdprint(":"); 
    if (opmode==1)
      lcdPrintDecimal(examine(octaladdress));
    else
      lcdPrintOctal(examine(octaladdress));
    kbmode=1;
    noctal=0;
    octalval=0;
    lcdclearline(1);
    lcdsetCursor(0,1);
    if (octaladdress<0xfffc) 
    { lcdprint("      :"); 
      lcdprint(printDisas(examine(octaladdress), 8));
    }
    else 
    { lcdprint("ac");
      lcdprint(octaladdress-0xfffc);
    }
    lcdnoCursor();
    if (opmode==0 or opmode==2) printHelp("*/8 = next/prev address; # = edit");
    if (opmode==1) printHelp("* = next address; # = edit");
    if (opmode==3) printHelp("#=step, 8=step back");
  }
  else if (kbkey==12 && kbmode<2 && opmode==0)  // # = start edit mode
  { if (kbmode==1 && noctal==1 && octalval<4) octaladdress = 0xfffc + (octalval&3);
    else if (kbmode==1 && noctal>=1) octaladdress=octalval; // allow e.g. 123#: edit 123
    kbmode = 2;
    noctal=0;
    octalval = examine(octaladdress);
    lcdclearline(0);
    lcdsetCursor(0,0);
    lcdPrintOctal(octaladdress); 
    lcdprint(":"); 
    lcdPrintOctal(octalval);
    lcdclearline(1);
    lcdsetCursor(0,1);
    if (octaladdress<0xfffc) 
    { lcdprint("      :"); 
      lcdprint(printDisas(examine(octaladdress), 8));
    }
    else 
    { lcdprint("ac");
      lcdprint(octaladdress-0xfffc);
    }
    printHelp("8/9 = left/right; # = store; * = cancel");
    lcdcursor();
    lcdsetCursor(7+noctal,0);
  }
  else if (kbkey==12 && kbmode<2 && opmode==1)  // # = start decimal edit mode
  { kbmode = 2;
    noctal=0;
    octalval=0;
    lcdclearline(0);
    lcdsetCursor(0,0);
    lcdPrintDecimal(octaladdress); 
    lcdprint(":"); 
    lcdprint(octalval);
    lcdclearline(1);
    lcdsetCursor(0,1);
    stopNova();
    if (octaladdress<0xfffc) 
    { lcdprint("      :"); 
      lcdprint(printDisas(examine(octaladdress), 8));
    }
    else 
    { lcdprint("ac");
      lcdprint(octaladdress-0xfffc);
    }
    printHelp("decimal mode # = store; * = cancel");
    lcdsetCursor(6+noctal,0);
    lcdnoCursor();
  }
  else if (kbkey==12 && kbmode==2 && (opmode==0 or opmode==2))  // # = edit mode deposit
  { if (opmode==2) octalval=packassemble(octalval);
    stopNova();
    deposit(octaladdress, octalval);
    lcdclearline(0);
    lcdsetCursor(0,0);
    lcdPrintOctal(octaladdress); 
    lcdprint("<"); 
    lcdPrintOctal(examine(octaladdress));
    kbmode=1;
    noctal=0;
    lcdclearline(1);
    lcdsetCursor(0,1);
    if (octaladdress<0xfffc) 
    { lcdprint("      <");
      lcdprint(printDisas(examine(octaladdress), 8));
    }
    else 
    { lcdprint(" ac");
      lcdprint(octaladdress-0xfffc);
    }
    printHelp("");
    lcdnoCursor();
  }
  else if (kbkey==12 && kbmode==2 && opmode==1)   // # = decimal mode deposit
  { stopNova();
    deposit(octaladdress, octalval);
    lcdclearline(0);
    lcdsetCursor(0,0);
    lcdPrintDecimal(octaladdress); 
    lcdprint("<"); 
    lcdPrintDecimal(examine(octaladdress));
    kbmode=1;
    noctal=0;
    lcdclearline(1);
    lcdsetCursor(0,1);
    if (octaladdress>=0xfffc) 
    { lcdprint(" ac");
      lcdprint(octaladdress-0xfffc);
    }
    printHelp("");
    lcdnoCursor();
  }
  else if (kbkey==12 && kbmode<2 && opmode==2)   // # = start assembly mode
  { stopNova();
    kbmode = 2;
    noctal=0;
    octalval = examine(octaladdress);
    octalval=unpackassemble(octalval);
    lcdclearline(0);
    lcdsetCursor(0,0);
    lcdPrintOctal(octaladdress); 
    lcdprint(":"); 
    lcdPrintLongOctal(octalval);
    lcdclearline(1);
    lcdsetCursor(0,1);
    lcdprint("      :"); 
    lcdprint(printMiniDisas(octalval, 8));
    printAssemblyHelp(octalval, noctal);
    lcdcursor();
    lcdsetCursor(7+noctal,0);
  }
  else if (opmode==3 && kbkey==12)      // step instruction
  { stopNova();
    prevpc = readAddr() & 0x7fff;
    kbmode=0;
    noctal=0;
    octalval=0;
    lcdnoCursor();
    stepNova();
    lcdPrintDebug();
    debugging=1;
  } 
  else if (opmode==3 && kbkey==8 && debugging)    // 'step back' instruction
  { stopNova();
    octaladdress = prevpc;
    prevpc = octaladdress-1;
    examine(octaladdress);
    lcdsetCursor(0,1);
    lcdPrintDebug(); 
    lcdnoCursor();
    kbmode=1;
    noctal=0;
    octalval=0;
  }
  else if (opmode==5 && kbkey>0)  // io mode
  { unsigned int a, kb=kbkey;
    if (kb==10) kb='*';
    else if (kb==11) kb='0';
    else if (kb==12) kb='#';
    else kb='0' + kb;
    bool runn = readLights()&1;
    if (runn) a=stopNova();
    deposit(CHARIN, kb);
    if (runn) 
      startNova(a);
    else 
    { if (haltInstruction == GETC)
      { depositAC(0, kb);
        examine(haltAddress);
        continueNova();
      }
      else
      { examine(haltAddress);
        continueNovaSw(kb);
      }
    }
  }
  else if (kbmode<3 && kbkey==9)      // select opmode
  { kbmode = 3;
    lcdsetCursor(0, 1);
    lcdprint("ex de as db su io ts sv ld rn");
    printHelp("Select run mode");
    while(readKeys()!=0);
    delay(50);
    lcdnoCursor();
  }
  else if (kbmode==3 && kbkey>0)      // select opmode
  { int kb=kbkey;
    if (kb==11) kb=0;
    kbmode = 0;
    if (kb<=8) opmode=kb;
    if (kb==9) 
    { if ((readLights()&1)==0)
      { printHelp(F("RUN")); startNova(octaladdress); return; }
      else
      { printHelp(F("STOP")); octaladdress=stopNova(); return; }
    }
    
    lcdclearline(1);
    if (opmode==0) printHelp(F("N*=AC NN*=exam mem #=edit 9=setup"));
    if (opmode==1) printHelp(F("N*=AC NN*=exam mem #=edit dec 9!=setup"));
    if (opmode==2) printHelp(F("N*=AC NN*=exam mem #=edit asm 9=setup"));
    if (opmode==3) printHelp(F("debug #=step 8=step back 9=setup"));
    if (opmode==4) printHelp(F("setup unused"));
    if (opmode==5) { printHelp(F("I/O mode 9(long)=exit")); lcdclear(); }
    if (opmode==6) { printHelp(F("0=regtest 1=dmp 2-5=mtst 7=pld 8=fullmtst")); lcdclear(); }
    if (opmode==7) { printHelp(F("Save core to eeprom bank N")); lcdclear(); }
    if (opmode==8) { printHelp(F("Load core from eeprom bank N")); lcdclear(); }
    lcdnoCursor();
  }
  else if (opmode==4 && kbkey>0)      // setup (not used)
  { int kb=kbkey;
    if (kb==11) kb=0;
    lcdclear();
    kbmode = 0;
    opmode = 0;
    printHelp("");
    lcdnoCursor();
  }
  else if (opmode==6 && kbkey>0)      // test menu
  { int kb=kbkey;
    if (kb==11) kb=0;
    tests(kb);
    lcdclear();
    kbmode = 0;
    opmode = 0;
    printHelp("");
    lcdnoCursor();
  }
  else if (opmode==7 && kbkey>0)      // save core
  { int kb=kbkey;
    if (kb==11) kb=0;
    if (kb<=5)
    { unsigned int b=0;
      for (int i=0; i<kb; i++) b += core_lengths[i];
      for (unsigned int i=0; i<core_lengths[kb]; i++) 
        writeBlocktoEEPROM(b+i, i*64);
    }
    lcdclear();
    kbmode = 0;
    opmode = 0;
    printHelp("");
    lcdnoCursor();
  }
  else if (opmode==8 && kbkey>0)      // load core
  { int kb=kbkey;
    if (kb==11) kb=0;
    if (kb<=5)
    { unsigned int b=0;
      for (int i=0; i<kb; i++) b += core_lengths[i];
      for (unsigned int i=0; i<core_lengths[kb]; i++) 
        readBlockfromEEPROM(b+i, i*64);
    }
    lcdclear();
    kbmode = 0;
    opmode = 0;
    printHelp("");
    lcdnoCursor();
  }
  else if (kbkey>0)       // unrecognised key
  { kbmode=0;
    noctal=0;
    octalval=0;
    lcdnoCursor();
  }
}

String tapeloader(const unsigned char*p, int len, String name)
{  Serial.println("Loading 'tape' from code memory: "+name);
   //Serial.println("Block:Address");
   int i=0, startaddress=0xffff;
   i=0;

   // skip zero preamble
   while (i<len)
   { if (p[i]!=0) break;
     i++;
   }
   while (i<len)
   { short wc = p[i] + p[i+1]*256;
     wc = -wc;
     i+=2;

     // data block
     if (wc>0 && wc<=16)
     { short adr = p[i] + p[i+1]*256;
       //Serial.println(toOct(wc)+':'+toOct(adr));
       i+=2;
       //short cs = p[i] + p[i+1]*256;
       i+=2;
       for (int j=0; j<wc; j++)
       { short data = p[i] + p[i+1]*256;
         deposit(adr+j, data);
         i+=2;
       }
     }
     // constant block
     else if (wc>16 && wc <= 32767)
     { short adr = p[i] + p[i+1]*256;
       //Serial.println(toOct(wc)+' '+toOct(adr));
       i+=2;
       //short cs = p[i] + p[i+1]*256;
       i+=2;
       short data = p[i] + p[i+1]*256;
       i+=2;
       for (int j=0; j<wc; j++)
       { deposit(adr+j, data);
       }
     }
     // start address block
     else if (wc == -1)
     { unsigned short adr = p[i] + p[i+1]*256;
       startaddress = adr;
              
       i+=2;
       i+=2;
       break;
     }
   }

   if (startaddress<32768) 
   { Serial.println("start adress "+toOct(startaddress));
     return "run "+toOct(startaddress);
   }

   return "";
}

// ------------------------------------------------------------
// Serial interface description, interactive mode all numbers in octal

String helpstring=
String("Interactive debugger/supervisor for Nova1200:\r\n")+
String("acN [ val]            read/write register\r\n")+
String("pc [ val]             read/write program counter\r\n")+
String("reg                   show all registers, pc and carry\r\n")+
String("mem addr [ val]       read/write memory location\r\n")+
String("Kaddr/val             write memory location(s)\r\n")+
String("val                   write next\r\n")+
String("K                     stop write mode\r\n")+
String("dump address[ length] dump memory\r\n")+
String("list address[ length] list assembly (numbers are octal)\r\n")+
String("asm addr INST         assemble to memory (slow, INST exactly as disassembled)\r\n")+
String("go addr               run at memory location\r\n")+
String("run addr              run at memory location, serial input passed to program\r\n")+
String("fp val                Set front panel switches\r\n")+
String("step [ count]         debug step count instructions\r\n")+
String("reset                 reset nova\r\n")+
String("stop                  stop nova\r\n")+
String("continue              continue nova\r\n")+
String("clear addr cnt [ val] clear block of memory with value\r\n")+
String("load addr block cnt   load RAM from eeprom blocks\r\n")+
String("save addr block cnt   save RAM to eeprom blocks\r\n")+
String("store                 store all RAM to highest eeprom blocks\r\n")+
String("restore               restore RAM from highest eeprom blocks\r\n")+
String("tape filename         Load tape data from eeprom or code memory\r\n")+
String("tape list             List all tapes in eeprom and code memory\r\n")+
String("test n                run test function\r\n")+
String("version               print version\r\n")+
String("lcd line text         display line 0..4 on LCD\r\n")+
String("led N                 program GPIO and Arduino LED (400)\r\n")+
String("adc N                 read 2,3=A2,A3\r\n")+
String("dac N                 write A14\r\n")+
String("reads                 read switches\r\n")+
String("readk                 read key\r\n")+
String("writed N              write data (without NOVA)\r\n")+
String("writea N              write address (without NOVA)\r\n")+
String("writel N              write lights (without NOVA)\r\n")+
String("eeprom block          hex dump eeprom block to output\r\n")+
String("memory address        hex dump memory block to output\r\n")+
String("plot address range    plot 80 values (+/- range)\r\n")+
String("vis address count     visualize memory as gray scale, default 1600 chars\r\n")+
String("init                  init Arduino supervisor\r\n")+
String(":nnaaaa[hhhh]         Deposit nn memory locations (a and h hex)\r\n")+
String(";naaaa[hh*16]         Write line n in eeprom block (a and h hex)\r\n")+
String("? $                   Write in hex ?lights ADSS $regs 1234pC\r\n")+
String("~                     Switch to non-interactive mode\r\n")+
String("help                  Show this text\r\n")+
String("(enter)               automatically propose next command");

// suggested named programs, search from start block (e.g. 4):
// @@ name loadaddress length startaddress
// CODE 
// block 4 + length/4 + 2:
// @@ name loadaddress length startaddress
// CODE
// other values (stops search)
//
// required support commands:
// save name addr length [start]
// save name (re-save same block)
// load name (suggests run start address as next command)
// run name
// go name

String line;
String nextcmd;
#define NHISTORY 40
String history[NHISTORY];
int nhist=0;
bool kmode=false;
int kaddress=0;

void processSerial(int count)
{ byte b = Serial.read();
  char m[50];
  int pc;
  int a;

  if (SerialIO or opmode==5) 
  { if (b=='@') 
    { SerialIO=false;
      opmode=0;
      Serial.println("interactive mode");
    }
    else if (b==3)
    { SerialIO=false;
      opmode=0;
      stopNova();
      Serial.println("ctrl-C");
      Serial.print(">");
      return;
    }
    else
    { 
#ifdef TEENSY

#ifdef SIMULATED
      //if (!DEV_IS_DONE(INT_TTI))
      { ttibuf= b;
        DEV_CLR_BUSY( INT_TTI ) ;
        DEV_SET_DONE( INT_TTI ) ;
        DEV_UPDATE_INTR ;
        return;
      }
#else
      Serial1.write(b);
#endif      

#else
      bool runn = readLights()&1;
      if (runn) a=stopNova();
      deposit(CHARIN, b);
      if (runn) 
       startNova(a);
      else 
      { if (haltInstruction == GETC)
        { depositAC(0, b);
          examine(haltAddress);
          continueNova();
        }
        else
        { examine(haltAddress);
          continueNovaSw(b);
        }
      }
#endif
    }
    return;
  }

  // ctrl-C
  if (b==3)
  { SerialIO=false;
    opmode=0;
    stopNova();
    Serial.println("ctrl-C");
    Serial.print(">");
    return;
  }

  // new interactive mode
  else 
  { if (b==27) // read escape key sequences (up and down)
    { int k = Serial.read();
      if (k=='[')
      { k = Serial.read();
        if (k=='A')
        { nhist--;
          if (nhist<0) nhist=0;
          line = history[nhist];
          Serial.write("\33[2K\r");
          Serial.print(">");
          Serial.print(line);
        }
        else if (k=='B')
        { nhist++;
          if (nhist>=NHISTORY) nhist=NHISTORY-1;
          line = history[nhist];
          Serial.write("\33[2K\r");
          Serial.print(">");
          Serial.print(line);
        }
      }
      else Serial.write(k);
    }
    else if (b==127 || b==8) // backspace
    { if (line.length()>0) 
      { line.remove(line.length()-1);
        Serial.write(8);
        Serial.write(32);
        Serial.write(8);
      }
    }
    else if (b != '\r' && b != '\n') 
    { line.concat(char(b)); 
      Serial.write(b);
    }

    // enter
    if (b == '\r') 
    { // auto suggest next command
      if (line=="" && nextcmd!="")
      { line=nextcmd;
        Serial.write("\33[2K\r");
        Serial.print(">");
        Serial.print(line);
        nextcmd="";
        return;
      }
  
      Serial.println();

      // search place to store history and store it
      nhist=-1;
      for (int i=0; i<NHISTORY; i++)
      { if (history[i]=="") 
        { history[i]=line;
          nhist=i+1;
          break;
        }
      }
      if (nhist==-1)
      { for (int i=1; i<NHISTORY; i++) 
        { history[i-1]=history[i];
        }
        nhist=NHISTORY-1;
        history[nhist++]=line;
      }

      // stop Nova when running
      if (readLights()&1) a=stopNova();
#ifdef SIMULATED
      pc=NovaPC&0x7fff;
#else
      pc=readAddr()&0x7fff;
#endif

      // show help text
      if (line.startsWith("help"))
      { Serial.println(helpstring);
      }

      // Nova virtual console deposit (Kaddress/data)
      else if (line.startsWith("K"))
      { int pos1 = 1;
        int pos2 = line.indexOf('/', 0);
        if (pos2<0)
        { kmode=false;
        }
        else
        { int a = readOct(line, pos1);
          int b = readOct(line, pos2+1);
          deposit(a, b);
          kmode=true;
          kaddress=a+1;
        }
      }
      else if (kmode && line[0]>'0' && line[0]<='7')
      { int b=readOct(line, 0);
        deposit(kaddress, b);
        kaddress++;
      }

      // disassemble
      else if (line.startsWith("list "))
      { int pos1 = 5;
        int pos2 = line.indexOf(' ', 6);
        unsigned short a = readOct(line, pos1);
        int b = pos2<0 ? 16 : readOct(line, pos2+1);
        for (unsigned short i=0; i<b; i++)
        { Serial.print(toOct(a));
          unsigned short v=examine(a++);
          Serial.print(" ");
          Serial.print(toOct(v));
          Serial.println(printDisas(v, OCT));
        }
        nextcmd = "list "+toOct(a)+" "+toOct(b);
        examine(pc);
      }
        
      // dump memory
      else if (line.startsWith("dump "))
      { int pos1 = 5;
        int pos2 = line.indexOf(' ', 6);
        unsigned short a = readOct(line, pos1);
        int b = pos2<0 ? 16 : readOct(line, pos2+1);
        for (unsigned short i=0; i<b; i++)
        { Serial.print(toOct(a));
          unsigned short v=examine(a++);
          Serial.print(" ");
          Serial.print(toOct(v));
          Serial.print(" ");
          Serial.print(char(max(v>>8,32)));
          Serial.print(char(max(v&255,32)));
          Serial.println("");
        }
        nextcmd = "dump "+toOct(a)+" "+toOct(b);
        examine(pc);
      }

      // read or set accumulator
      else if (line.startsWith("ac"))
      { int pos1 = 2;
        int pos2 = line.indexOf(' ', 3);
        unsigned short a = readOct(line, pos1);
        if (pos2>=0) depositAC(a, readOct(line, pos2+1));
        Serial.println("ac"+String(a)+" = "+toOct(examineAC(a)));
        if (pos2>=0) nextcmd = "ac"+String((a+1)%4)+" "+toOct(readOct(line, pos2+1));
        else nextcmd = "ac"+String((a+1)%4);
      }

      // read or set pc
      else if (line.startsWith("pc"))
      { int pos2 = line.indexOf(' ', 2);
        if (pos2>=0) examine(readOct(line, pos2+1));
#ifdef SIMULATED
        NovaPC = readOct(line, pos2+1);
        Serial.println("pc = "+toOct(NovaPC&0x7fff));
#else
        Serial.println("pc = "+toOct(readAddr()&0x7fff));
#endif
        nextcmd = "step";
      }

      // show all registers
      else if (line.startsWith("reg"))
      { for (int a=0; a<4; a++)
          Serial.println("ac"+String(a)+" = "+toOct(examineAC(a)));
#ifdef SIMULATED
        Serial.println("pc = "+toOct(NovaPC&0x7fff));
        Serial.println("carry = "+String(NovaC!=0));
#else
        Serial.println("pc = "+toOct(readAddr()&0x7fff));
        Serial.println("carry = "+String(readAddr()>>15));
#endif
        nextcmd = "";
      }

      // read or set memory location
      else if (line.startsWith("mem "))
      { int pos1 = 4;
        int pos2 = line.indexOf(' ', 5);
        unsigned short a = readOct(line, pos1);
        if (pos2>=0) deposit(a, readOct(line, pos2+1));
        Serial.println("mem "+toOct(a)+" = "+toOct(examine(a)));
        examine(pc);
        if (pos2>=0) nextcmd = "mem "+toOct(a+1)+" "+toOct(readOct(line, pos2+1));
        else nextcmd = "mem "+toOct(a+1);
      }

      // assemble instruction
      else if (line.startsWith("asm "))
      { int pos1 = 4;
        int pos2 = line.indexOf(' ', 5);
        unsigned short a = readOct(line, pos1);
        if (pos2>=0) {
          String t=line.substring(pos2).toLowerCase();

          // shortcuts to frequent routines, must be in memory to work
          if      (t==" .mul"   ) deposit(a, 0x043e); // JMS @3e etc
          else if (t==" .div"   ) deposit(a, 0x043f);
          else if (t==" .sys"   ) deposit(a, 0x0440);
          else if (t==" .memclr") deposit(a, 0x045b);
          else if (t==" .memcpy") deposit(a, 0x045c);
          else if (t.startsWith(" .db "))     // .db num or .db "string"
          { int pos3 = t.indexOf('"');
            if (pos3>0)
            { int pos4=t.indexOf('"',pos3+1);
              t = t.substring(pos3+1, pos4);
              int j=t.length()+1;
              if (j&1) j++;
              for (int i=0; i<j; i+=2, a++)
                deposit(a, ((t[i]<<8)+t[i+1]));
              a--;
            }
            else
            { pos3 = t.indexOf(' ', 4);
              unsigned short b = readOct(t, pos3+1);
              deposit(a, b);
            }
          }

          else for(int b=0; b<=65535;)
          { String s = printDisas(b, OCT).toLowerCase();
            if (s.substring(0, 4)!=t.substring(0, 4) && (((b&63)!=63)))
              b+=63; 
            // must be different instruction (all coded in high 10 bits)
            else if (s.equals(t))
            { deposit(a, b);
              break;
            }
            else 
              b++;
          }
          nextcmd = "asm "+toOct(a+1)+" ";
        }
        Serial.print(toOct(a));
        unsigned short v=examine(a++);
        Serial.print(" ");
        Serial.print(toOct(v));
        Serial.println(printDisas(v, OCT));
        examine(pc);
      }

      // run without serial IO
      else if (line.startsWith("go "))
      { int pos1 = 3;
        unsigned short a = readOct(line, pos1);
        Serial.println("running");
        startNova(a);
        nextcmd = "stop";
      }

      // run with serial IO
      else if (line.startsWith("run "))
      { int pos1 = 4;
        SerialIO=true;
        unsigned short a = readOct(line, pos1);
        Serial.println("running, use ctrl-c to return to command mode");
        startNova(a);
        nextcmd = "stop";
      }

      else if (line.startsWith("reset"))
      { resetNova();
        stopNova(); 
        if(SerialIO or opmode==5) 
        { Serial.println("interactive mode");
          SerialIO=false; opmode=0; 
        }  
        nextcmd = "";
      }

      else if (line.startsWith("stop"))
      { stopNova(); 
        if(SerialIO or opmode==5) 
        { Serial.println("interactive mode");
          SerialIO=false; opmode=0; 
        }  
        nextcmd = "continue";
      }

      else if (line.startsWith("continue"))
      { continueNova(); 
        nextcmd = "stop";
      }

      else if (line.startsWith("init")) {
        setup();
        delay(100);
        nextcmd = "";
      }

      else if (line.startsWith("version")) {
        Serial.println("Nova1210 front panel code Marcel van Herk " __DATE__);
#ifdef SIMULATED
        Serial.println("Simulated mode: Contains parts of simhv3-9");
#endif
  nextcmd = "";
      }

      // load memory from eeprom
      else if (line.startsWith("load "))
      { int pos1 = 5;
        int pos2 = line.indexOf(' ', 6);
        int pos3 = line.indexOf(' ', pos2+1);
        if (pos2>=0 && pos3>=0)
        { unsigned short a = readOct(line, pos1);
          unsigned short b = readOct(line, pos2+1);
          unsigned short c = readOct(line, pos3+1);
          unsigned short s=a;
          for (int block=b; block<b+c; block++,a+=64)
            readBlockfromEEPROM(block, a);
          Serial.println("loaded memory "+toOct(s)+ " with " + c + " blocks");
          nextcmd = "run "+toOct(a);
        }
        else
          nextcmd = "";
        examine(pc);
      }

      // save memory to eeprom
      else if (line.startsWith("save "))
      { int pos1 = 5;
        int pos2 = line.indexOf(' ', 6);
        int pos3 = line.indexOf(' ', pos2+1);
        if (pos2>=0 && pos3>=0)
        { unsigned short a = readOct(line, pos1);
          unsigned short b = readOct(line, pos2+1);
          unsigned short c = readOct(line, pos3+1);
          unsigned short s=a;
          for (int block=b; block<b+c; block++,a+=64)
            writeBlocktoEEPROM(block, a);
          Serial.println("saved memory "+toOct(s)+ " total of " + c + " blocks");
        }
        nextcmd = "";
        examine(pc);
      }

      // restore memory from eeprom
      else if (line.startsWith("restore"))
        nextcmd = restore();

      // store memory to eeprom
      else if (line.startsWith("store"))
        nextcmd = store();

      // debug step
      else if (line.startsWith("step"))
      { int pos2 = line.indexOf(' ', 4);
        unsigned short a = pos2>0 ? readOct(line, pos2+1) : 1;
        for (int i=0; i<a; i++) {
          serialDebug(1);
          serialDebug(2); 
          Serial.println();
          stepNova();
        }
        nextcmd = "step "+toOct(a);
      }

      // print lights status
      else if (line.startsWith("lights")) {
        Serial.println("Data="+toOct(readData())); 
        Serial.println("Addr="+toOct(readAddr())); 
        Serial.println("Status="+toOct(readLights()));
        nextcmd = "lights";
      }

      // run test function (may not return)
      else if (line.startsWith("test "))
      { int pos1 = 5;
        unsigned short a = readOct(line, pos1);
        tests(a);
      }

      // set line of LCD
      else if (line.startsWith("lcd "))
      { int pos1 = 4;
        int pos2 = line.indexOf(' ', pos1+1);
        if (pos2>=0)
        { unsigned short a = readOct(line, pos1);
          display(a, line.substring(pos2+1));
          nextcmd = "lcd "+String((a+1)%5)+" "+line.substring(pos2+1);
        }
      }

      // program leds
      else if (line.startsWith("led "))
      { int pos1 = 4;
        unsigned short a = readOct(line, pos1);
        //gpio(a & 255);
        digitalWrite(13, (a>>8)&1);
        //digitalWrite(12, (a>>9)&1);
        //digitalWrite(11, (a>>10)&1);
        writeColor(a&15);
        nextcmd = "led "+toOct(a+1);
      }
          
      // program DAC
      else if (line.startsWith("dac "))
      { int pos1 = 4;
        unsigned short a = readOct(line, pos1);
        analogWrite(A14, a);
        nextcmd = "dac "+toOct(a+1);
      }

      // read switches bank
      else if (line.startsWith("reads"))
      { Serial.println("Switches="+toOct(readSwitches())); 
        nextcmd = "reads";
      }

      // read key
      else if (line.startsWith("readk"))
      { Serial.println("Key="+toOct(readKeys())); 
        nextcmd = "readk";
      }

      // write data bus (for unconnected nova)
      else if (line.startsWith("writed "))
      { int pos1 = 7;
        unsigned short a = readOct(line, pos1);
        writeData(a);
        nextcmd = "writed "+toOct(a+1);
      }

      // write address bus (for unconnected nova)
      else if (line.startsWith("writea "))
      { int pos1 = 7;
        unsigned short a = readOct(line, pos1);
        writeAddr(a);
        nextcmd = "writea "+toOct(a+1);
      }

      // write lights (for unconnected nova)
      else if (line.startsWith("writel "))
      { int pos1 = 7;
        unsigned short a = readOct(line, pos1);
        writeLights(a);
        nextcmd = "writel "+toOct(a+1);
      }

      // read ADC
      else if (line.startsWith("adc"))
      { 
        int pos1 = 4;
        int pins[8] = {A0, A1, A2, A3, A4, A5, A6, A7};
        int pin=readOct(line, pos1);
        pinMode(pins[pin&7], INPUT);
        Serial.println("adc"+String(pin)+"="+toOct(analogRead(pins[pin&7])));
        nextcmd = "adc";
      }

      // list eeprom block in hex
      else if (line.startsWith("eeprom "))
      { int pos1 = 7;
        unsigned short a = readOct(line, pos1);
        int deviceaddress = 0x50;                  
        if (a>515) deviceaddress+=4;
        for (short i=0; i<128; i++)
        { String s;
          if (a<4) s = toHex2(EEPROM.read(a*128+i));
          else     s = toHex2(i2c_eeprom_read_byte(deviceaddress, (a-4)*128+i));
          if ((i&15)==15) Serial.println(s); else Serial.print(s);
        }
        nextcmd = "eeprom "+toOct(a+1);
      }

      // list memory block in hex
      else if (line.startsWith("memory "))
      { int pos1 = 7;
        unsigned short a = readOct(line, pos1);
        for (short i=0; i<64; i++)
        { String s;
          s = toHex(examine(a+i));
          if ((i&7)==7) Serial.println(s); else Serial.print(s);
        }
        nextcmd = "memory "+toOct(a+64);
      }

      // clear block of memory
      else if (line.startsWith("clear "))
      { int pos1 = 6;
        int pos2 = line.indexOf(' ', 7);
        int pos3 = line.indexOf(' ', pos2+1);
        if (pos2>=0)
        { unsigned short a = readOct(line, pos1);
          unsigned short b = readOct(line, pos2+1);
          unsigned short c = pos3<0 ? 0 : readOct(line, pos3+1);
          unsigned short s=a;
          for (int i=0; i<b; i++)
            deposit(s+i, c);
          Serial.println("cleared memory "+toOct(s)+ " " + toOct(b) + " words to " + toOct(c));
          nextcmd = "dump "+toOct(a);
        }
        else
          nextcmd = "";
        examine(pc);
      }

      // load hex data to memory
      else if (line.startsWith(":"))
      { line.toCharArray(m, 50);
        unsigned short n = readHex(m+1,2);
        unsigned short a=readHex(m+3,4);
        if (n<=10) for (unsigned short i=0; i<n; i++) deposit(a++, readHex(m+7+i*4,4));
        nextcmd = "";
      }

      // load hex data (16 bytes) to eeprom
      else if (line.startsWith(";"))
      { line.toCharArray(m, 50);
        unsigned short n = readHex(m+1,1);
        unsigned short a=readHex(m+2,4);
        int deviceaddress = 0x50;
        if (a>515) deviceaddress+=4;
        for (short i=0; i<16; i++) m[i]=readHex(m+6+i*2,2);
        if (a<4) for (short j=0; j<16; j++) EEPROM.write(a*128+n*16+j, m[j]);
        else     i2c_eeprom_write_page(deviceaddress, (a-4)*128+n*16, (byte *)m, 16);
        nextcmd = "";
      }

      else if (line.startsWith("?"))
      { Serial.print(toHex(readAddr())); 
        Serial.print(toHex(readData())); 
        Serial.println(toHex2(readLights()));
        nextcmd = "?";
      }

      // dump all registers in hex
      else if (line.startsWith("$"))
      { for (int a=0; a<4; a++)
          Serial.print(toHex(examineAC(a)));
        Serial.println(toHex(readAddr()));
        nextcmd = "";
      }

      // visualize memory as gray scale a=address b=length of visualization (default 1600 = 20 lines)
      else if (line.startsWith("vis "))
      { int pos1 = 4;
        int pos2 = line.indexOf(' ', 5);
        unsigned short a = readOct(line, pos1);
        int b = pos2<0 ? 1600 : readOct(line, pos2+1);
        for (unsigned short i=0; i<b; i++)
        { unsigned short v=examine(a++);
          char visual[]=" .:-=+*#%@";
          short w = v/2048;
          if (v>=32768) Serial.print("-");
          else if (w>=(int)strlen(visual)) Serial.print("+");
          else Serial.write(visual[w]);
          if (i%80==79) Serial.println("");
        }
        nextcmd = "vis "+toOct(a)+" "+toOct(b);
        examine(pc);
      }

      // plot memory a=address b=value range (applied positive and negative)
      else if (line.startsWith("plot "))
      { int pos1 = 5;
        int pos2 = line.indexOf(' ', 6);
        unsigned short a = readOct(line, pos1);
        int b = pos2<0 ? 32767 : readOct(line, pos2+1);
        short vals[80];
        for (unsigned short i=0; i<80; i++) 
          vals[i] = examine(a++);
        for (short i=10; i>=-10; i--)
        { for (unsigned short j=0; j<80; j++)
          {  short v = (10*(int)vals[j] + b/2)/b;
             if (v==i) Serial.print("*");
             else if (i==0) Serial.print("-");
             else Serial.print(" ");
           }
          Serial.println("");
        }
        nextcmd = "plot "+toOct(a)+" "+toOct(b);
        examine(pc);
      }

      // write serial character
      else if (line.startsWith("serw "))
      { int pos1 = 5;
        unsigned short a = readOct(line, pos1);
        Serial1.write(a);
        nextcmd = "serw "+toOct(a+1);
      }

      // set front panel switches
      else if (line.startsWith("fp "))
      { int pos1 = 3;
        unsigned short a = readOct(line, pos1);
        CurrentSwitchValue=a;
      }

      // absolute tape loader using data in eeprom; tape data is stored after 16 bytes $$llFILENAME@; where ll is its 16 bits length
      else if (line.startsWith("tape "))
      { int pos1 = 5;
        String filename = line.substring(pos1, 99).toUpperCase(); // +"@";

        // absolute tape loader using program data
        if (filename==".BASIC")
        { nextcmd=tapeloader(basictape, sizeof(basictape), ".basic");
          Serial.print(">");
          line = "";
          return;
        }
        if (filename==".BASIC2")
        { nextcmd=tapeloader(basic2tape, sizeof(basic2tape), ".basic2");
          Serial.print(">");
          line = "";
          return;
        }

        if (filename=="LIST")
        { Serial.println(".BASIC in code memory; length "+toOct(sizeof(basictape)));
        }

        byte fname[16], ename[16];
        filename.getBytes(fname, 16);
        int deviceaddress = 0x50;                  
          
        // search all 128 character blocks on external eeprom (address 4 and up)
        int block=-1;
        for(int a=4; a<1028; a++)
        { if (a>515) deviceaddress+=4;
          block = -1;
          if (i2c_eeprom_read_byte(deviceaddress, (a-4)*128+0)=='$')
          { if (i2c_eeprom_read_byte(deviceaddress, (a-4)*128+1)=='$')
            { block = a;
              for (unsigned short i=0; i<16; i++)
              { ename[i] = i2c_eeprom_read_byte(deviceaddress, (a-4)*128+i+4);
                if (ename[i]==0) 
                { break;
                }
                if (fname[i]!=ename[i] && block!=-1) 
                { block=-1;
                }
              }
              if (filename=="LIST")
              { String str((char *)ename);
                int len = i2c_eeprom_read_byte(deviceaddress, (a-4)*128+2) + i2c_eeprom_read_byte(deviceaddress, (a-4)*128+3)*256;
                Serial.println(str+" at block "+toOct(a)+"; length "+toOct(len)+" next block: "+toOct(a+(int)ceil((len+16)/128)));
              }
            }
          }
          if (block>=4) break;
        }
        if (block>=0 && filename!="LIST")
        { block-=4;
          int len = i2c_eeprom_read_byte(deviceaddress, block*128+2) + i2c_eeprom_read_byte(deviceaddress, block*128+3)*256;
          Serial.println("Loading tape "+filename+" at eeprom block "+toOct(block)+"; length "+toOct(len)+" next block: "+toOct(block+(int)ceil((len+16)/128)));
          Serial.println("Block:Address");
          int a=block*128+16, i=0, startaddress=0xffff;
          i=0;
          // skip zero preamble
          while (i<len)
          { if (i2c_eeprom_read_byte(deviceaddress, a+i)!=0) break;
            i++;
          }
          while (i<len)
          { short wc = i2c_eeprom_read_byte(deviceaddress, a+i) + i2c_eeprom_read_byte(deviceaddress, a+i+1)*256;
            wc = -wc;
            i+=2;

            // data block
            if (wc>0 && wc<=16)
            { short adr = i2c_eeprom_read_byte(deviceaddress, a+i) + i2c_eeprom_read_byte(deviceaddress, a+i+1)*256;
              Serial.println(toOct(wc)+':'+toOct(adr));
              i+=2;
              //short cs = i2c_eeprom_read_byte(deviceaddress, a+i) + i2c_eeprom_read_byte(deviceaddress, a+i+1)*256;
              i+=2;
              for (int j=0; j<wc; j++)
              { short data = i2c_eeprom_read_byte(deviceaddress, a+i) + i2c_eeprom_read_byte(deviceaddress, a+i+1)*256;
                deposit(adr+j, data);
                i+=2;
              }
            }
            // constant block
            else if (wc>16 && wc <= 32767)
            { short adr = i2c_eeprom_read_byte(deviceaddress, a+i) + i2c_eeprom_read_byte(deviceaddress, a+i+1)*256;
              Serial.println(toOct(wc)+' '+toOct(adr));
              i+=2;
              //short cs = i2c_eeprom_read_byte(deviceaddress, a+i) + i2c_eeprom_read_byte(deviceaddress, a+i+1)*256;
              i+=2;
              short data = i2c_eeprom_read_byte(deviceaddress, a+i) + i2c_eeprom_read_byte(deviceaddress, a+i+1)*256;
              i+=2;
              for (int j=0; j<wc; j++)
              { deposit(adr+j, data);
              }
            }
            // start address block
            else if (wc == -1)
            { unsigned short adr = i2c_eeprom_read_byte(deviceaddress, a+i) + i2c_eeprom_read_byte(deviceaddress, a+i+1)*256;
              startaddress = adr;
              
              i+=2;
              i+=2;
              break;
            }
          }
          if (startaddress<32768) 
          { Serial.println("start adress "+toOct(startaddress));
            nextcmd = "run "+toOct(startaddress);
          }
        }
        else if(filename!="LIST")
          Serial.println("Tape "+filename+" not found");
      }

      Serial.print(">");
      line = "";
    }
  }
}

void setup() {
  delay(10);

  pinMode(13, OUTPUT); // LED doubles with SSCLK for SPI

  digitalWrite(13, HIGH);

  // reset all I2C buffer chips
  WireBegin();
  for (int i=0; i<0x16; i++)
  { writeByte(0x20, i, 0x00);
    writeByte(0x21, i, 0x00);
    writeByte(0x22, i, 0x00);
    writeByte(0x23, i, 0x00);
    writeByte(0x24, i, 0x00);
  }
  WireEnd();

  digitalWrite(13, LOW);

  // program all lights to be input
  readAddr();
  readData();
  readLights();

  digitalWrite(13, LOW);

  // you MUST initialize all displays
  for (int i=0; i<5; i++)
  { selectDisplay(i);
    u8g2.begin();
  }

  digitalWrite(13, HIGH);

  display(1,"DATA GENERAL");
  display(2, "CORPORATION");
#ifdef SIMULATED
  display(4, "NOVA 1210 S");
#else
  display(4, "NOVA 1210");
#endif

  digitalWrite(13, LOW);

  writeControlReg(0); // all NOVA control signals inactive

  // setup terminal window emulator
  selectDisplay(3);
  u8g2.setFont(defaultFont);  
  u8g2log.begin(u8g2, U8LOG_WIDTH, U8LOG_HEIGHT, u8log_buffer); // connect to u8g2, assign buffer
  u8g2log.setLineHeightOffset(0); // set extra space between lines in pixel, this can be negative
  u8g2log.setRedrawMode(0);   // 0: Update screen with newline, 1: Update screen for every char  

  digitalWrite(13, HIGH);

  selectDisplay(3);
  u8g2log.print("Nova 1210 front panel");
  u8g2log.print("\n");
  u8g2log.print("By Marcel van Herk " __DATE__ "\n");
  u8g2log.print("Memory size ");
  u8g2log.print(memsize);
  u8g2log.print(" words");
  u8g2log.print("\n");
#ifdef SIMULATED
  u8g2log.print("Contains parts of simhv39-0\n");
#endif

// keep last screen on Teensy3.5 (no front panel)
#ifndef TEENSY35
  selectDisplay(0);
  u8g2.clear();
#endif

  digitalWrite(13, LOW);

  writeDataReg(0);
  writeInstReg(0); // TODO: correct start status

  // TODO: memory size test

  Serial.begin(115200);     // usb serial for debug output
  Serial.setTimeout(5000);

  Serial1.setTX(1); // serial to nova
  Serial1.setRX(0);
  Serial1.begin(4800,SERIAL_8N1);
}

short i=0;
int prev=0;
int startKey=0;
void loop(void) {
  if (Serial1.available())
  { byte b = Serial1.read();
    Serial.write(b&0x7f);
    return;
  }

  // wait and detect halt condition; special bits in HALT are interpreted as 'OS' instructions
#ifdef SIMULATED
  while (false)
#else
  while (millis() - currentMillis < 100)
#endif
  { bool runLight = readLights()&1;
    if (novaRunning && !runLight) {
      haltAddress     = readAddr() & 0x7fff;
      haltInstruction = examine(haltAddress-1);
      haltA0          = examineAC(0);
      novaRunning     = false;

      if (kbmode==3) haltInstruction=0; // allow key 9 to stop running

      if (haltInstruction==INFO)
      { lcdPrintDebug();
        examine(haltAddress);
        continueNova();
        continue;
      }
      else if (haltInstruction==PUTC) // write character
      { byte b=haltA0&255;
        Serial.write(b);
        //u8g2log.write(b);
        examine(haltAddress);
        continueNova();
        continue;
      }
      else if (haltInstruction==MESSAGE) // write character string from address in A2
      { int a = examineAC(2);
        bool flag=false;
        for (int i=0; i<40; i++)
        { unsigned short s=examine(a+i);
          unsigned short s2=examine(a+i+1);
          byte b = s>>8;
          if (b==0) break;
          if (!flag)
          { if (b=='%') { Serial.print(String((short)examineAC(s&3))); flag=true; }
            else Serial.write(b);
            //u8g2log.write(b);
          }
          else
            flag=false;
          b = s&255;
          if (b==0) break;
          if (!flag)
          { if (b=='%') { Serial.print(String((short)examineAC((s2>>8)&3))); flag=true; }
            else Serial.write(b);
            //u8g2log.write(b);
          }
          else
            flag=false;
        }
        examine(haltAddress);
        continueNova();
        continue;
      }
      else if (haltInstruction==WRITELED)
      { 
#ifndef TEENSY
        //digitalWrite(6, 1);  // poor attempt to keep LCD tidy as LED doubles as LCD2 select
        //digitalWrite(A2, 1);
        //digitalWrite(A3, 1);
        //digitalWrite(A4, 1);
        //digitalWrite(A5, 1);
#endif
        //digitalWrite(13, (haltA0&1)!=0);
#ifdef TEENSY
        //digitalWrite(12, (haltA0&2)!=0);
        //digitalWrite(11, (haltA0&4)!=0);
        writeColor(haltA0&15);
        analogWrite(A14, haltA0>>4);
#endif
#ifndef TEENSY
        delay(50); // must be shorter than 100 ms above!
        digitalWrite(13, 0);
#endif
        examine(haltAddress);
        continueNova();
        continue;
      }
      else if (haltInstruction==READBLOCK) // stored BIGENDIAN in eeprom
      { unsigned int A2=examineAC(2);
        //gpio(1);
        readBlockfromEEPROM(haltA0, A2);
        depositAC(0, haltA0+1);
        depositAC(2, A2+64);
        //gpio(0);
        examine(haltAddress);
        continueNova();
        continue;
      }
      //else if (haltInstruction==SKIPBUSYZ) // skip when character available
      //{ if (true)
      //    examine(haltAddress+1);
      //  else
      //    examine(haltAddress);
      //  continueNova();
      //  continue;
     // }
      else if (haltInstruction==WRITEBLOCK) // read BIGENDIAN from eeprom
      { unsigned int A2=examineAC(2);
        //gpio(4);
        writeBlocktoEEPROM(haltA0, A2);
        //gpio(0);
        depositAC(0, haltA0+1);
        depositAC(2, A2+64);
        examine(haltAddress);
        continueNova();
        continue;
      }
      else if (haltInstruction==GPIO)     // GPIO through MCP20008
      { //gpio(haltA0);
        examine(haltAddress);
        continueNova();
        continue;
      }
      else if (haltInstruction==DELAY)   // delay on arduino
      { examineAC(1); // show ac1 on lights
        delay(haltA0);
        examine(haltAddress);
        continueNova();
        continue;
      }
      else if (haltInstruction==ADC)   // adc on teensy
      { 
#ifdef TEENSY
        pinMode(A0, INPUT);
        depositAC(0, analogRead(A0));
#else
        pinMode(A1, INPUT);
        depositAC(0, analogRead(A1));
#endif
        examine(haltAddress);
        continueNova();
        continue;
      }
      else if (haltInstruction==GETC)
      { break; // handled in serial and keyboard code
      }
      else if (haltInstruction==HALT)
      { Serial.println("HALT at address: "+toOct(haltAddress));
        Serial.print(">");
        SerialIO=false;
        return; // Normal halt: nova ready for input
      }
    }

    if (SerialIO==false && opmode!=5) break;
  }

  int count=0;

  if ((count=Serial.available()))
  { processSerial(count);
    if (SerialIO) return;
  }

  int kbkey;
  if ((kbkey=readKeys()))
  { int k=millis();
    if (startKey==0) startKey=millis();
    processkey(kbkey);
    while (readKeys()) {
      if ((count=Serial.available()))
      { processSerial(count);
        if (SerialIO) return;
      }
      if (millis()-k>100 && millis()-startKey>1000) return;
    }
  }
  else
    startKey=0;
}
